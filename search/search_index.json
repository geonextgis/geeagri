{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geeagri","text":"<p>Python tools for agricultural analysis powered by Google Earth Engine.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://geonextgis.github.io/geeagri</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#geeagri.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>geeagri/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/geonextgis/geeagri/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geeagri could always use more documentation, whether as part of the official geeagri docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/geonextgis/geeagri/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geeagri for local development.</p> <ol> <li> <p>Fork the geeagri repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geeagri.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geeagri\n$ cd geeagri/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geeagri tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/geonextgis/geeagri/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"geeagri/","title":"geeagri module","text":"<p>Main module.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install geeagri, run this command in your terminal:</p> <pre><code>pip install geeagri\n</code></pre> <p>This is the preferred method to install geeagri, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install geeagri from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/geonextgis/geeagri\n</code></pre>"},{"location":"timeseries/","title":"timeseries module","text":"<p>Module for timeseries analysis on Earth Engine data.</p>"},{"location":"timeseries/#geeagri.timeseries.HarmonicRegression","title":"<code> HarmonicRegression        </code>","text":"<p>Perform harmonic regression on an Earth Engine ImageCollection.</p> <p>Attributes:</p> Name Type Description <code>image_collection</code> <code>ee.ImageCollection</code> <p>Input time series of selected band.</p> <code>ref_date</code> <code>ee.Date</code> <p>Reference date to calculate time.</p> <code>band</code> <code>str</code> <p>Name of dependent variable band.</p> <code>order</code> <code>int</code> <p>Number of harmonics.</p> <code>omega</code> <code>float</code> <p>Base frequency multiplier.</p> <code>independents</code> <code>List[str]</code> <p>Names of independent variable bands.</p> <code>composite</code> <code>ee.Image</code> <p>Median composite of the selected band.</p> Source code in <code>geeagri/timeseries.py</code> <pre><code>class HarmonicRegression:\n    \"\"\"\n    Perform harmonic regression on an Earth Engine ImageCollection.\n\n    Attributes:\n        image_collection (ee.ImageCollection): Input time series of selected band.\n        ref_date (ee.Date): Reference date to calculate time.\n        band (str): Name of dependent variable band.\n        order (int): Number of harmonics.\n        omega (float): Base frequency multiplier.\n        independents (List[str]): Names of independent variable bands.\n        composite (ee.Image): Median composite of the selected band.\n    \"\"\"\n\n    def __init__(self, image_collection, ref_date, band_name, order=1, omega=1):\n        \"\"\"\n        Initialize the HarmonicRegression object.\n\n        Args:\n            image_collection (ee.ImageCollection): Input image collection.\n            ref_date (str or ee.Date): Reference date to compute relative time.\n            band_name (str): Name of dependent variable band.\n            order (int): Number of harmonics (default 1).\n            omega (float): Base frequency multiplier (default 1).\n        \"\"\"\n        self.image_collection = image_collection.select(band_name)\n        self.ref_date = ee.Date(ref_date) if isinstance(ref_date, str) else ref_date\n        self.band = band_name\n        self.order = order\n        self.omega = omega\n\n        # Names of independent variables: constant, cos_1, ..., sin_1, ...\n        self.independents = (\n            [\"constant\"]\n            + [f\"cos_{i}\" for i in range(1, order + 1)]\n            + [f\"sin_{i}\" for i in range(1, order + 1)]\n        )\n\n        # Precompute median composite of the selected band\n        self.composite = self.image_collection.median()\n\n    def _add_time_unit(self, image):\n        \"\"\"\n        Add time difference in years from ref_date as band 't'.\n\n        Args:\n            image (ee.Image): Input image.\n\n        Returns:\n            ee.Image: Image with additional 't' band.\n        \"\"\"\n        dyear = ee.Number(image.date().difference(self.ref_date, \"year\"))\n        return image.addBands(ee.Image.constant(dyear).rename(\"t\").float())\n\n    def _add_harmonics(self, image):\n        \"\"\"\n        Add harmonic basis functions: constant, cos_i, sin_i bands.\n\n        Args:\n            image (ee.Image): Input image.\n\n        Returns:\n            ee.Image: Image with added harmonic bands.\n        \"\"\"\n        image = self._add_time_unit(image)\n        t = image.select(\"t\")\n\n        harmonic_bands = [ee.Image.constant(1).rename(\"constant\")]\n        for i in range(1, self.order + 1):\n            freq = ee.Number(i).multiply(self.omega).multiply(2 * math.pi)\n            harmonic_bands.append(t.multiply(freq).cos().rename(f\"cos_{i}\"))\n            harmonic_bands.append(t.multiply(freq).sin().rename(f\"sin_{i}\"))\n\n        return image.addBands(ee.Image(harmonic_bands))\n\n    def get_harmonic_coeffs(self):\n        \"\"\"\n        Fit harmonic regression and return coefficients image.\n\n        Returns:\n            ee.Image: Coefficients image with bands like &lt;band&gt;_constant, &lt;band&gt;_cos_1, etc.\n        \"\"\"\n        harmonic_coll = self.image_collection.map(self._add_harmonics)\n\n        regression = harmonic_coll.select(self.independents + [self.band]).reduce(\n            ee.Reducer.linearRegression(len(self.independents), 1)\n        )\n\n        coeffs = (\n            regression.select(\"coefficients\")\n            .arrayProject([0])\n            .arrayFlatten([self.independents])\n            .multiply(10000)\n            .toInt32()\n        )\n\n        new_names = [f\"{self.band}_{name}\" for name in self.independents]\n        return coeffs.rename(new_names)\n\n    def get_phase_amplitude(\n        self, harmonic_coeffs, cos_band, sin_band, stretch_factor=1, return_rgb=True\n    ):\n        \"\"\"\n        Compute phase &amp; amplitude and optionally create RGB visualization.\n\n        Args:\n            harmonic_coeffs (ee.Image): Coefficients image from get_harmonic_coeffs().\n            cos_band (str): Name of cosine coefficient band.\n            sin_band (str): Name of sine coefficient band.\n            stretch_factor (float): Stretch amplitude to enhance contrast.\n            return_rgb (bool): If True, return RGB image; else return HSV image.\n\n        Returns:\n            ee.Image: RGB visualization (uint8) or HSV image.\n        \"\"\"\n        phase = harmonic_coeffs.select(cos_band).atan2(harmonic_coeffs.select(sin_band))\n        amplitude = harmonic_coeffs.select(cos_band).hypot(\n            harmonic_coeffs.select(sin_band)\n        )\n\n        hsv = (\n            phase.unitScale(-math.pi, math.pi)\n            .addBands(amplitude.multiply(stretch_factor))\n            .addBands(self.composite)\n        )\n\n        if return_rgb:\n            return hsv.hsvToRgb().unitScale(0, 1).multiply(255).toByte()\n        else:\n            return hsv\n\n    def _fit_harmonics(self, harmonic_coeffs, image):\n        \"\"\"\n        Compute fitted values from harmonic coefficients and harmonic bands.\n\n        Args:\n            harmonic_coeffs (ee.Image): Coefficients image divided by 10000.\n            image (ee.Image): Image with harmonic bands.\n\n        Returns:\n            ee.Image: Image with fitted values.\n        \"\"\"\n        return (\n            image.select(self.independents)\n            .multiply(harmonic_coeffs)\n            .reduce(\"sum\")\n            .rename(\"fitted\")\n            .copyProperties(image, [\"system:time_start\"])\n        )\n\n    def get_fitted_harmonics(self, harmonic_coeffs):\n        \"\"\"\n        Compute fitted harmonic time series over the collection.\n\n        Args:\n            harmonic_coeffs (ee.Image): Coefficients image from get_harmonic_coeffs().\n\n        Returns:\n            ee.ImageCollection: Collection with fitted harmonic value as 'fitted' band.\n        \"\"\"\n        harmonic_coeffs_scaled = harmonic_coeffs.divide(10000)\n        harmonic_coll = self.image_collection.map(self._add_harmonics)\n\n        return harmonic_coll.map(\n            lambda img: self._fit_harmonics(harmonic_coeffs_scaled, img)\n        )\n</code></pre>"},{"location":"timeseries/#geeagri.timeseries.HarmonicRegression.__init__","title":"<code>__init__(self, image_collection, ref_date, band_name, order=1, omega=1)</code>  <code>special</code>","text":"<p>Initialize the HarmonicRegression object.</p> <p>Parameters:</p> Name Type Description Default <code>image_collection</code> <code>ee.ImageCollection</code> <p>Input image collection.</p> required <code>ref_date</code> <code>str or ee.Date</code> <p>Reference date to compute relative time.</p> required <code>band_name</code> <code>str</code> <p>Name of dependent variable band.</p> required <code>order</code> <code>int</code> <p>Number of harmonics (default 1).</p> <code>1</code> <code>omega</code> <code>float</code> <p>Base frequency multiplier (default 1).</p> <code>1</code> Source code in <code>geeagri/timeseries.py</code> <pre><code>def __init__(self, image_collection, ref_date, band_name, order=1, omega=1):\n    \"\"\"\n    Initialize the HarmonicRegression object.\n\n    Args:\n        image_collection (ee.ImageCollection): Input image collection.\n        ref_date (str or ee.Date): Reference date to compute relative time.\n        band_name (str): Name of dependent variable band.\n        order (int): Number of harmonics (default 1).\n        omega (float): Base frequency multiplier (default 1).\n    \"\"\"\n    self.image_collection = image_collection.select(band_name)\n    self.ref_date = ee.Date(ref_date) if isinstance(ref_date, str) else ref_date\n    self.band = band_name\n    self.order = order\n    self.omega = omega\n\n    # Names of independent variables: constant, cos_1, ..., sin_1, ...\n    self.independents = (\n        [\"constant\"]\n        + [f\"cos_{i}\" for i in range(1, order + 1)]\n        + [f\"sin_{i}\" for i in range(1, order + 1)]\n    )\n\n    # Precompute median composite of the selected band\n    self.composite = self.image_collection.median()\n</code></pre>"},{"location":"timeseries/#geeagri.timeseries.HarmonicRegression.get_fitted_harmonics","title":"<code>get_fitted_harmonics(self, harmonic_coeffs)</code>","text":"<p>Compute fitted harmonic time series over the collection.</p> <p>Parameters:</p> Name Type Description Default <code>harmonic_coeffs</code> <code>ee.Image</code> <p>Coefficients image from get_harmonic_coeffs().</p> required <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>Collection with fitted harmonic value as 'fitted' band.</p> Source code in <code>geeagri/timeseries.py</code> <pre><code>def get_fitted_harmonics(self, harmonic_coeffs):\n    \"\"\"\n    Compute fitted harmonic time series over the collection.\n\n    Args:\n        harmonic_coeffs (ee.Image): Coefficients image from get_harmonic_coeffs().\n\n    Returns:\n        ee.ImageCollection: Collection with fitted harmonic value as 'fitted' band.\n    \"\"\"\n    harmonic_coeffs_scaled = harmonic_coeffs.divide(10000)\n    harmonic_coll = self.image_collection.map(self._add_harmonics)\n\n    return harmonic_coll.map(\n        lambda img: self._fit_harmonics(harmonic_coeffs_scaled, img)\n    )\n</code></pre>"},{"location":"timeseries/#geeagri.timeseries.HarmonicRegression.get_harmonic_coeffs","title":"<code>get_harmonic_coeffs(self)</code>","text":"<p>Fit harmonic regression and return coefficients image.</p> <p>Returns:</p> Type Description <code>ee.Image</code> <p>Coefficients image with bands like _constant, _cos_1, etc. Source code in <code>geeagri/timeseries.py</code> <pre><code>def get_harmonic_coeffs(self):\n    \"\"\"\n    Fit harmonic regression and return coefficients image.\n\n    Returns:\n        ee.Image: Coefficients image with bands like &lt;band&gt;_constant, &lt;band&gt;_cos_1, etc.\n    \"\"\"\n    harmonic_coll = self.image_collection.map(self._add_harmonics)\n\n    regression = harmonic_coll.select(self.independents + [self.band]).reduce(\n        ee.Reducer.linearRegression(len(self.independents), 1)\n    )\n\n    coeffs = (\n        regression.select(\"coefficients\")\n        .arrayProject([0])\n        .arrayFlatten([self.independents])\n        .multiply(10000)\n        .toInt32()\n    )\n\n    new_names = [f\"{self.band}_{name}\" for name in self.independents]\n    return coeffs.rename(new_names)\n</code></pre>"},{"location":"timeseries/#geeagri.timeseries.HarmonicRegression.get_phase_amplitude","title":"<code>get_phase_amplitude(self, harmonic_coeffs, cos_band, sin_band, stretch_factor=1, return_rgb=True)</code>","text":"<p>Compute phase &amp; amplitude and optionally create RGB visualization.</p> <p>Parameters:</p> Name Type Description Default <code>harmonic_coeffs</code> <code>ee.Image</code> <p>Coefficients image from get_harmonic_coeffs().</p> required <code>cos_band</code> <code>str</code> <p>Name of cosine coefficient band.</p> required <code>sin_band</code> <code>str</code> <p>Name of sine coefficient band.</p> required <code>stretch_factor</code> <code>float</code> <p>Stretch amplitude to enhance contrast.</p> <code>1</code> <code>return_rgb</code> <code>bool</code> <p>If True, return RGB image; else return HSV image.</p> <code>True</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>RGB visualization (uint8) or HSV image.</p> Source code in <code>geeagri/timeseries.py</code> <pre><code>def get_phase_amplitude(\n    self, harmonic_coeffs, cos_band, sin_band, stretch_factor=1, return_rgb=True\n):\n    \"\"\"\n    Compute phase &amp; amplitude and optionally create RGB visualization.\n\n    Args:\n        harmonic_coeffs (ee.Image): Coefficients image from get_harmonic_coeffs().\n        cos_band (str): Name of cosine coefficient band.\n        sin_band (str): Name of sine coefficient band.\n        stretch_factor (float): Stretch amplitude to enhance contrast.\n        return_rgb (bool): If True, return RGB image; else return HSV image.\n\n    Returns:\n        ee.Image: RGB visualization (uint8) or HSV image.\n    \"\"\"\n    phase = harmonic_coeffs.select(cos_band).atan2(harmonic_coeffs.select(sin_band))\n    amplitude = harmonic_coeffs.select(cos_band).hypot(\n        harmonic_coeffs.select(sin_band)\n    )\n\n    hsv = (\n        phase.unitScale(-math.pi, math.pi)\n        .addBands(amplitude.multiply(stretch_factor))\n        .addBands(self.composite)\n    )\n\n    if return_rgb:\n        return hsv.hsvToRgb().unitScale(0, 1).multiply(255).toByte()\n    else:\n        return hsv\n</code></pre>"},{"location":"timeseries/#geeagri.timeseries.extract_timeseries_to_point","title":"<code>extract_timeseries_to_point(lat, lon, image_collection, start_date=None, end_date=None, band_names=None, scale=None, crs=None, crsTransform=None, out_csv=None)</code>","text":"<p>Extracts pixel time series from an ee.ImageCollection at a point.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude of the point.</p> required <code>lon</code> <code>float</code> <p>Longitude of the point.</p> required <code>image_collection</code> <code>ee.ImageCollection</code> <p>Image collection to sample.</p> required <code>start_date</code> <code>str</code> <p>Start date (e.g., '2020-01-01').</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date (e.g., '2020-12-31').</p> <code>None</code> <code>band_names</code> <code>list</code> <p>List of bands to extract.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Sampling scale in meters.</p> <code>None</code> <code>crs</code> <code>str</code> <p>Projection CRS. Defaults to image CRS.</p> <code>None</code> <code>crsTransform</code> <code>list</code> <p>CRS transform matrix (3x2 row-major). Overrides scale.</p> <code>None</code> <code>out_csv</code> <code>str</code> <p>File path to save CSV. If None, returns a DataFrame.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame or None</code> <p>Time series data if not exporting to CSV.</p> Source code in <code>geeagri/timeseries.py</code> <pre><code>def extract_timeseries_to_point(\n    lat,\n    lon,\n    image_collection,\n    start_date=None,\n    end_date=None,\n    band_names=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    out_csv=None,\n):\n    \"\"\"\n    Extracts pixel time series from an ee.ImageCollection at a point.\n\n    Args:\n        lat (float): Latitude of the point.\n        lon (float): Longitude of the point.\n        image_collection (ee.ImageCollection): Image collection to sample.\n        start_date (str, optional): Start date (e.g., '2020-01-01').\n        end_date (str, optional): End date (e.g., '2020-12-31').\n        band_names (list, optional): List of bands to extract.\n        scale (float, optional): Sampling scale in meters.\n        crs (str, optional): Projection CRS. Defaults to image CRS.\n        crsTransform (list, optional): CRS transform matrix (3x2 row-major). Overrides scale.\n        out_csv (str, optional): File path to save CSV. If None, returns a DataFrame.\n\n    Returns:\n        pd.DataFrame or None: Time series data if not exporting to CSV.\n    \"\"\"\n    import pandas as pd\n    from datetime import datetime\n\n    if not isinstance(image_collection, ee.ImageCollection):\n        raise ValueError(\"image_collection must be an instance of ee.ImageCollection.\")\n\n    property_names = image_collection.first().propertyNames().getInfo()\n    if \"system:time_start\" not in property_names:\n        raise ValueError(\"The image collection lacks the 'system:time_start' property.\")\n\n    point = ee.Geometry.Point([lon, lat])\n\n    try:\n        if start_date and end_date:\n            image_collection = image_collection.filterDate(start_date, end_date)\n        if band_names:\n            image_collection = image_collection.select(band_names)\n        image_collection = image_collection.filterBounds(point)\n    except Exception as e:\n        raise RuntimeError(f\"Error filtering image collection: {e}\")\n\n    try:\n        result = image_collection.getRegion(\n            geometry=point, scale=scale, crs=crs, crsTransform=crsTransform\n        ).getInfo()\n\n        result_df = pd.DataFrame(result[1:], columns=result[0])\n\n        if result_df.empty:\n            raise ValueError(\n                \"Extraction returned an empty DataFrame. Check your point, date range, or selected bands.\"\n            )\n\n        result_df[\"time\"] = result_df[\"time\"].apply(\n            lambda t: datetime.utcfromtimestamp(t / 1000)\n        )\n\n        if out_csv:\n            result_df.to_csv(out_csv, index=False)\n        else:\n            return result_df\n\n    except Exception as e:\n        raise RuntimeError(f\"Error extracting data: {e}.\")\n</code></pre>"},{"location":"timeseries/#geeagri.timeseries.extract_timeseries_to_polygon","title":"<code>extract_timeseries_to_polygon(polygon, image_collection, start_date=None, end_date=None, band_names=None, scale=None, crs=None, reducer='MEAN', out_csv=None)</code>","text":"<p>Extracts time series statistics over a polygon from an ee.ImageCollection.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>ee.Geometry.Polygon</code> <p>Polygon geometry.</p> required <code>image_collection</code> <code>ee.ImageCollection</code> <p>Image collection to sample.</p> required <code>start_date</code> <code>str</code> <p>Start date (e.g., '2020-01-01').</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date (e.g., '2020-12-31').</p> <code>None</code> <code>band_names</code> <code>list</code> <p>List of bands to extract.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Sampling scale in meters.</p> <code>None</code> <code>crs</code> <code>str</code> <p>Projection CRS. Defaults to image CRS.</p> <code>None</code> <code>reducer</code> <code>str or ee.Reducer</code> <p>Name of reducer or ee.Reducer instance.</p> <code>'MEAN'</code> <code>out_csv</code> <code>str</code> <p>File path to save CSV. If None, returns a DataFrame.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame or None</code> <p>Time series data if not exporting to CSV.</p> Source code in <code>geeagri/timeseries.py</code> <pre><code>def extract_timeseries_to_polygon(\n    polygon,\n    image_collection,\n    start_date=None,\n    end_date=None,\n    band_names=None,\n    scale=None,\n    crs=None,\n    reducer=\"MEAN\",\n    out_csv=None,\n):\n    \"\"\"\n    Extracts time series statistics over a polygon from an ee.ImageCollection.\n\n    Args:\n        polygon (ee.Geometry.Polygon): Polygon geometry.\n        image_collection (ee.ImageCollection): Image collection to sample.\n        start_date (str, optional): Start date (e.g., '2020-01-01').\n        end_date (str, optional): End date (e.g., '2020-12-31').\n        band_names (list, optional): List of bands to extract.\n        scale (float, optional): Sampling scale in meters.\n        crs (str, optional): Projection CRS. Defaults to image CRS.\n        reducer (str or ee.Reducer): Name of reducer or ee.Reducer instance.\n        out_csv (str, optional): File path to save CSV. If None, returns a DataFrame.\n\n    Returns:\n        pd.DataFrame or None: Time series data if not exporting to CSV.\n    \"\"\"\n    import pandas as pd\n    from datetime import datetime\n\n    if not isinstance(image_collection, ee.ImageCollection):\n        raise ValueError(\"image_collection must be an instance of ee.ImageCollection.\")\n    if not isinstance(polygon, ee.Geometry):\n        raise ValueError(\"polygon must be an instance of ee.Geometry.\")\n\n    # Allowed reducers\n    allowed_statistics = {\n        \"COUNT\": ee.Reducer.count(),\n        \"MEAN\": ee.Reducer.mean(),\n        \"MEAN_UNWEIGHTED\": ee.Reducer.mean().unweighted(),\n        \"MAXIMUM\": ee.Reducer.max(),\n        \"MEDIAN\": ee.Reducer.median(),\n        \"MINIMUM\": ee.Reducer.min(),\n        \"MODE\": ee.Reducer.mode(),\n        \"STD\": ee.Reducer.stdDev(),\n        \"MIN_MAX\": ee.Reducer.minMax(),\n        \"SUM\": ee.Reducer.sum(),\n        \"VARIANCE\": ee.Reducer.variance(),\n    }\n\n    # Get reducer from string or use directly\n    if isinstance(reducer, str):\n        reducer_upper = reducer.upper()\n        if reducer_upper not in allowed_statistics:\n            raise ValueError(\n                f\"Reducer '{reducer}' not supported. Choose from: {list(allowed_statistics.keys())}\"\n            )\n        reducer = allowed_statistics[reducer_upper]\n    elif not isinstance(reducer, ee.Reducer):\n        raise ValueError(\"reducer must be a string or an ee.Reducer instance.\")\n\n    # Filter dates and bands\n    if start_date and end_date:\n        image_collection = image_collection.filterDate(start_date, end_date)\n    if band_names:\n        image_collection = image_collection.select(band_names)\n\n    image_collection = image_collection.filterBounds(polygon)\n\n    def image_to_dict(image):\n        date = ee.Date(image.get(\"system:time_start\")).format(\"YYYY-MM-dd\")\n        stats = image.reduceRegion(\n            reducer=reducer, geometry=polygon, scale=scale, crs=crs, maxPixels=1e13\n        )\n        return ee.Feature(None, stats).set(\"time\", date)\n\n    stats_fc = image_collection.map(image_to_dict).filter(\n        ee.Filter.notNull(image_collection.first().bandNames())\n    )\n\n    try:\n        stats_list = stats_fc.getInfo()[\"features\"]\n    except Exception as e:\n        raise RuntimeError(f\"Error retrieving data from GEE: {e}\")\n\n    if not stats_list:\n        raise ValueError(\"No data returned for the given polygon and parameters.\")\n\n    records = []\n    for f in stats_list:\n        props = f[\"properties\"]\n        records.append(props)\n\n    df = pd.DataFrame(records)\n    df[\"time\"] = pd.to_datetime(df[\"time\"])\n    df.insert(0, \"time\", df.pop(\"time\"))\n\n    if out_csv:\n        df.to_csv(out_csv, index=False)\n    else:\n        return df\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use geeagri in a project:</p> <pre><code>import geeagri\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[\u00a0]: Copied! <pre>print(\"Hello World!\")\n</pre> print(\"Hello World!\")"},{"location":"examples/timeseries_extraction/","title":"Timeseries extraction","text":"<p>Uncomment the following line to install geeagri if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geeagri\n</pre> # !pip install geeagri In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nfrom geeagri.timeseries import (\n    extract_timeseries_to_point,\n    extract_timeseries_to_polygon,\n)\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nplt.rcParams[\"font.family\"] = \"DeJavu Serif\"\nplt.rcParams[\"font.serif\"] = \"Times New Roman\"\n</pre> import ee import geemap from geeagri.timeseries import (     extract_timeseries_to_point,     extract_timeseries_to_polygon, )  import matplotlib.pyplot as plt import seaborn as sns  plt.rcParams[\"font.family\"] = \"DeJavu Serif\" plt.rcParams[\"font.serif\"] = \"Times New Roman\" In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>bbox = [-120.398369, 37.006574, -120.208168, 37.101924]\npolygon = ee.Geometry.BBox(*bbox)\npolygon_style = {\"color\": \"red\", \"width\": 1}\nMap.addLayer(polygon, polygon_style, \"Polygon\")\nMap.centerObject(polygon, 12)\n\nlat, lon = 37.0510, -120.3022\npoint = ee.Geometry.Point([lon, lat])\nMap.addLayer(point, {\"color\": \"blue\"}, \"Point\")\n</pre> bbox = [-120.398369, 37.006574, -120.208168, 37.101924] polygon = ee.Geometry.BBox(*bbox) polygon_style = {\"color\": \"red\", \"width\": 1} Map.addLayer(polygon, polygon_style, \"Polygon\") Map.centerObject(polygon, 12)  lat, lon = 37.0510, -120.3022 point = ee.Geometry.Point([lon, lat]) Map.addLayer(point, {\"color\": \"blue\"}, \"Point\") In\u00a0[\u00a0]: Copied! <pre>era5_land = ee.ImageCollection(\"ECMWF/ERA5_LAND/DAILY_AGGR\")\n\nera5_land_point_ts = extract_timeseries_to_point(\n    lat=lat,\n    lon=lon,\n    image_collection=era5_land,\n    start_date=\"2010-01-01\",\n    end_date=\"2015-01-01\",\n    band_names=[\n        \"temperature_2m_min\",\n        \"temperature_2m_max\",\n        \"total_precipitation_sum\",\n        \"surface_solar_radiation_downwards_sum\",\n    ],\n    scale=11132,\n)\n\nera5_land_polygon_ts = extract_timeseries_to_polygon(\n    polygon=polygon,\n    image_collection=era5_land,\n    start_date=\"2010-01-01\",\n    end_date=\"2015-01-01\",\n    band_names=[\n        \"temperature_2m_min\",\n        \"temperature_2m_max\",\n        \"total_precipitation_sum\",\n        \"surface_solar_radiation_downwards_sum\",\n    ],\n    scale=11132,\n    reducer=\"MEAN\",\n)\n</pre> era5_land = ee.ImageCollection(\"ECMWF/ERA5_LAND/DAILY_AGGR\")  era5_land_point_ts = extract_timeseries_to_point(     lat=lat,     lon=lon,     image_collection=era5_land,     start_date=\"2010-01-01\",     end_date=\"2015-01-01\",     band_names=[         \"temperature_2m_min\",         \"temperature_2m_max\",         \"total_precipitation_sum\",         \"surface_solar_radiation_downwards_sum\",     ],     scale=11132, )  era5_land_polygon_ts = extract_timeseries_to_polygon(     polygon=polygon,     image_collection=era5_land,     start_date=\"2010-01-01\",     end_date=\"2015-01-01\",     band_names=[         \"temperature_2m_min\",         \"temperature_2m_max\",         \"total_precipitation_sum\",         \"surface_solar_radiation_downwards_sum\",     ],     scale=11132,     reducer=\"MEAN\", ) In\u00a0[\u00a0]: Copied! <pre># Plot the data\nfig, axes = plt.subplots(nrows=2, ncols=1, figsize=(12, 6))\naxes = axes.flatten()\n\nsns.lineplot(\n    data=era5_land_point_ts,\n    x=\"time\",\n    y=\"temperature_2m_max\",\n    c=\"r\",\n    linewidth=0.5,\n    ax=axes[0],\n    label=\"Tmax\",\n)\nsns.lineplot(\n    data=era5_land_point_ts,\n    x=\"time\",\n    y=\"temperature_2m_min\",\n    c=\"b\",\n    linewidth=0.5,\n    ax=axes[0],\n    label=\"Tmax\",\n)\naxes[0].set_ylabel(\"Values\")\naxes[0].legend()\naxes[0].set_title(\"Daily timeseries of climate data based on point\")\n\nsns.lineplot(\n    data=era5_land_polygon_ts,\n    x=\"time\",\n    y=\"temperature_2m_max\",\n    c=\"r\",\n    linewidth=0.5,\n    ax=axes[1],\n    label=\"Tmax\",\n)\nsns.lineplot(\n    data=era5_land_polygon_ts,\n    x=\"time\",\n    y=\"temperature_2m_min\",\n    c=\"b\",\n    linewidth=0.5,\n    ax=axes[1],\n    label=\"Tmax\",\n)\naxes[1].set_ylabel(\"Values\")\naxes[1].legend()\naxes[1].set_title(\"Daily timeseries of climate data based on polygon\")\n\nplt.tight_layout()\nplt.show()\n</pre> # Plot the data fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(12, 6)) axes = axes.flatten()  sns.lineplot(     data=era5_land_point_ts,     x=\"time\",     y=\"temperature_2m_max\",     c=\"r\",     linewidth=0.5,     ax=axes[0],     label=\"Tmax\", ) sns.lineplot(     data=era5_land_point_ts,     x=\"time\",     y=\"temperature_2m_min\",     c=\"b\",     linewidth=0.5,     ax=axes[0],     label=\"Tmax\", ) axes[0].set_ylabel(\"Values\") axes[0].legend() axes[0].set_title(\"Daily timeseries of climate data based on point\")  sns.lineplot(     data=era5_land_polygon_ts,     x=\"time\",     y=\"temperature_2m_max\",     c=\"r\",     linewidth=0.5,     ax=axes[1],     label=\"Tmax\", ) sns.lineplot(     data=era5_land_polygon_ts,     x=\"time\",     y=\"temperature_2m_min\",     c=\"b\",     linewidth=0.5,     ax=axes[1],     label=\"Tmax\", ) axes[1].set_ylabel(\"Values\") axes[1].legend() axes[1].set_title(\"Daily timeseries of climate data based on polygon\")  plt.tight_layout() plt.show() In\u00a0[\u00a0]: Copied! <pre>modis_ndvi = ee.ImageCollection(\"MODIS/061/MOD13Q1\")\n\nmodis_ndvi_point_ts = extract_timeseries_to_point(\n    lat=lat,\n    lon=lon,\n    image_collection=modis_ndvi,\n    start_date=\"2010-01-01\",\n    end_date=\"2015-01-01\",\n    band_names=[\"NDVI\", \"EVI\"],\n    scale=250,\n)\n\nmodis_ndvi_polygon_ts = extract_timeseries_to_polygon(\n    polygon=polygon,\n    image_collection=modis_ndvi,\n    start_date=\"2010-01-01\",\n    end_date=\"2015-01-01\",\n    band_names=[\"NDVI\", \"EVI\"],\n    scale=250,\n    reducer=\"MEAN\",\n)\n\n# Apply scale factors\nmodis_ndvi_point_ts[[\"NDVI\", \"EVI\"]] = modis_ndvi_point_ts[[\"NDVI\", \"EVI\"]] * 0.0001\nmodis_ndvi_polygon_ts[[\"NDVI\", \"EVI\"]] = modis_ndvi_polygon_ts[[\"NDVI\", \"EVI\"]] * 0.0001\n</pre> modis_ndvi = ee.ImageCollection(\"MODIS/061/MOD13Q1\")  modis_ndvi_point_ts = extract_timeseries_to_point(     lat=lat,     lon=lon,     image_collection=modis_ndvi,     start_date=\"2010-01-01\",     end_date=\"2015-01-01\",     band_names=[\"NDVI\", \"EVI\"],     scale=250, )  modis_ndvi_polygon_ts = extract_timeseries_to_polygon(     polygon=polygon,     image_collection=modis_ndvi,     start_date=\"2010-01-01\",     end_date=\"2015-01-01\",     band_names=[\"NDVI\", \"EVI\"],     scale=250,     reducer=\"MEAN\", )  # Apply scale factors modis_ndvi_point_ts[[\"NDVI\", \"EVI\"]] = modis_ndvi_point_ts[[\"NDVI\", \"EVI\"]] * 0.0001 modis_ndvi_polygon_ts[[\"NDVI\", \"EVI\"]] = modis_ndvi_polygon_ts[[\"NDVI\", \"EVI\"]] * 0.0001 In\u00a0[\u00a0]: Copied! <pre># Plot the data\nfig, axes = plt.subplots(nrows=2, ncols=1, figsize=(12, 6))\naxes = axes.flatten()\n\nsns.lineplot(\n    data=modis_ndvi_point_ts,\n    x=\"time\",\n    y=\"NDVI\",\n    c=\"green\",\n    marker=\"o\",\n    markersize=5,\n    linewidth=1,\n    ax=axes[0],\n    label=\"NDVI\",\n)\nsns.lineplot(\n    data=modis_ndvi_point_ts,\n    x=\"time\",\n    y=\"EVI\",\n    c=\"orange\",\n    marker=\"o\",\n    markersize=5,\n    linewidth=1,\n    ax=axes[0],\n    label=\"EVI\",\n)\naxes[0].set_ylabel(\"Values\")\naxes[0].legend()\naxes[0].set_title(\"Daily timeseries of NDVI and EVI data based on point\")\n\nsns.lineplot(\n    data=modis_ndvi_polygon_ts,\n    x=\"time\",\n    y=\"NDVI\",\n    c=\"green\",\n    marker=\"o\",\n    markersize=5,\n    linewidth=1,\n    ax=axes[1],\n    label=\"NDVI\",\n)\nsns.lineplot(\n    data=modis_ndvi_polygon_ts,\n    x=\"time\",\n    y=\"EVI\",\n    c=\"orange\",\n    marker=\"o\",\n    markersize=5,\n    linewidth=1,\n    ax=axes[1],\n    label=\"EVI\",\n)\naxes[1].set_ylabel(\"Values\")\naxes[1].legend()\naxes[1].set_title(\"Daily timeseries of NDVI and EVI data based on polygon\")\n\nplt.tight_layout()\nplt.show()\n</pre> # Plot the data fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(12, 6)) axes = axes.flatten()  sns.lineplot(     data=modis_ndvi_point_ts,     x=\"time\",     y=\"NDVI\",     c=\"green\",     marker=\"o\",     markersize=5,     linewidth=1,     ax=axes[0],     label=\"NDVI\", ) sns.lineplot(     data=modis_ndvi_point_ts,     x=\"time\",     y=\"EVI\",     c=\"orange\",     marker=\"o\",     markersize=5,     linewidth=1,     ax=axes[0],     label=\"EVI\", ) axes[0].set_ylabel(\"Values\") axes[0].legend() axes[0].set_title(\"Daily timeseries of NDVI and EVI data based on point\")  sns.lineplot(     data=modis_ndvi_polygon_ts,     x=\"time\",     y=\"NDVI\",     c=\"green\",     marker=\"o\",     markersize=5,     linewidth=1,     ax=axes[1],     label=\"NDVI\", ) sns.lineplot(     data=modis_ndvi_polygon_ts,     x=\"time\",     y=\"EVI\",     c=\"orange\",     marker=\"o\",     markersize=5,     linewidth=1,     ax=axes[1],     label=\"EVI\", ) axes[1].set_ylabel(\"Values\") axes[1].legend() axes[1].set_title(\"Daily timeseries of NDVI and EVI data based on polygon\")  plt.tight_layout() plt.show()"},{"location":"examples/timeseries_extraction/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"examples/timeseries_extraction/#initialize-a-map-object","title":"Initialize a Map object\u00b6","text":""},{"location":"examples/timeseries_extraction/#import-region-of-interest","title":"Import region of interest\u00b6","text":""},{"location":"examples/timeseries_extraction/#export-timeseries-from-climate-data-era5-land-daily","title":"Export timeseries from climate data (ERA5-Land Daily)\u00b6","text":""},{"location":"examples/timeseries_extraction/#export-timeseries-from-ndvi-data-mod13q1061-terra-vegetation-indices-16-day","title":"Export timeseries from NDVI data (MOD13Q1.061 Terra Vegetation Indices 16-Day)\u00b6","text":""}]}