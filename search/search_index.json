{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geeagri","text":"<p>Python tools for agricultural analysis powered by Google Earth Engine.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://geonextgis.github.io/geeagri</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#geeagri.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>geeagri/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/geonextgis/geeagri/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geeagri could always use more documentation, whether as part of the official geeagri docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/geonextgis/geeagri/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geeagri for local development.</p> <ol> <li> <p>Fork the geeagri repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geeagri.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geeagri\n$ cd geeagri/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geeagri tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/geonextgis/geeagri/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"geeagri/","title":"geeagri module","text":"<p>Main module.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install geeagri, run this command in your terminal:</p> <pre><code>pip install geeagri\n</code></pre> <p>This is the preferred method to install geeagri, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install geeagri from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/geonextgis/geeagri\n</code></pre>"},{"location":"timeseries/","title":"timeseries module","text":"<p>Module for timeseries analysis on Earth Engine data.</p>"},{"location":"timeseries/#geeagri.timeseries.HarmonicRegression","title":"<code> HarmonicRegression        </code>","text":"<p>Perform harmonic regression on an Earth Engine ImageCollection.</p> <p>Attributes:</p> Name Type Description <code>image_collection</code> <code>ee.ImageCollection</code> <p>Input time series of selected band.</p> <code>ref_date</code> <code>ee.Date</code> <p>Reference date to calculate time.</p> <code>band</code> <code>str</code> <p>Name of dependent variable band.</p> <code>order</code> <code>int</code> <p>Number of harmonics.</p> <code>omega</code> <code>float</code> <p>Base frequency multiplier.</p> <code>independents</code> <code>List[str]</code> <p>Names of independent variable bands.</p> <code>composite</code> <code>ee.Image</code> <p>Median composite of the selected band.</p> Source code in <code>geeagri/timeseries.py</code> <pre><code>class HarmonicRegression:\n    \"\"\"\n    Perform harmonic regression on an Earth Engine ImageCollection.\n\n    Attributes:\n        image_collection (ee.ImageCollection): Input time series of selected band.\n        ref_date (ee.Date): Reference date to calculate time.\n        band (str): Name of dependent variable band.\n        order (int): Number of harmonics.\n        omega (float): Base frequency multiplier.\n        independents (List[str]): Names of independent variable bands.\n        composite (ee.Image): Median composite of the selected band.\n    \"\"\"\n\n    def __init__(self, image_collection, ref_date, band_name, order=1, omega=1):\n        \"\"\"\n        Initialize the HarmonicRegression object.\n\n        Args:\n            image_collection (ee.ImageCollection): Input image collection.\n            ref_date (str or ee.Date): Reference date to compute relative time.\n            band_name (str): Name of dependent variable band.\n            order (int): Number of harmonics (default 1).\n            omega (float): Base frequency multiplier (default 1).\n        \"\"\"\n        self.image_collection = image_collection.select(band_name)\n        self.ref_date = ee.Date(ref_date) if isinstance(ref_date, str) else ref_date\n        self.band = band_name\n        self.order = order\n        self.omega = omega\n\n        # Names of independent variables: constant, cos_1, ..., sin_1, ...\n        self.independents = (\n            [\"constant\"]\n            + [f\"cos_{i}\" for i in range(1, order + 1)]\n            + [f\"sin_{i}\" for i in range(1, order + 1)]\n        )\n\n        # Precompute median composite of the selected band\n        self.composite = self.image_collection.median()\n\n    def _add_time_unit(self, image):\n        \"\"\"\n        Add time difference in years from ref_date as band 't'.\n\n        Args:\n            image (ee.Image): Input image.\n\n        Returns:\n            ee.Image: Image with additional 't' band.\n        \"\"\"\n        dyear = ee.Number(image.date().difference(self.ref_date, \"year\"))\n        return image.addBands(ee.Image.constant(dyear).rename(\"t\").float())\n\n    def _add_harmonics(self, image):\n        \"\"\"\n        Add harmonic basis functions: constant, cos_i, sin_i bands.\n\n        Args:\n            image (ee.Image): Input image.\n\n        Returns:\n            ee.Image: Image with added harmonic bands.\n        \"\"\"\n        image = self._add_time_unit(image)\n        t = image.select(\"t\")\n\n        harmonic_bands = [ee.Image.constant(1).rename(\"constant\")]\n        for i in range(1, self.order + 1):\n            freq = ee.Number(i).multiply(self.omega).multiply(2 * math.pi)\n            harmonic_bands.append(t.multiply(freq).cos().rename(f\"cos_{i}\"))\n            harmonic_bands.append(t.multiply(freq).sin().rename(f\"sin_{i}\"))\n\n        return image.addBands(ee.Image(harmonic_bands))\n\n    def get_harmonic_coeffs(self):\n        \"\"\"\n        Fit harmonic regression and return coefficients image.\n\n        Returns:\n            ee.Image: Coefficients image with bands like &lt;band&gt;_constant, &lt;band&gt;_cos_1, etc.\n        \"\"\"\n        harmonic_coll = self.image_collection.map(self._add_harmonics)\n\n        regression = harmonic_coll.select(self.independents + [self.band]).reduce(\n            ee.Reducer.linearRegression(len(self.independents), 1)\n        )\n\n        coeffs = (\n            regression.select(\"coefficients\")\n            .arrayProject([0])\n            .arrayFlatten([self.independents])\n            .multiply(10000)\n            .toInt32()\n        )\n\n        new_names = [f\"{self.band}_{name}\" for name in self.independents]\n        return coeffs.rename(new_names)\n\n    def get_phase_amplitude(\n        self, harmonic_coeffs, cos_band, sin_band, stretch_factor=1, return_rgb=True\n    ):\n        \"\"\"\n        Compute phase &amp; amplitude and optionally create RGB visualization.\n\n        Args:\n            harmonic_coeffs (ee.Image): Coefficients image from get_harmonic_coeffs().\n            cos_band (str): Name of cosine coefficient band.\n            sin_band (str): Name of sine coefficient band.\n            stretch_factor (float): Stretch amplitude to enhance contrast.\n            return_rgb (bool): If True, return RGB image; else return HSV image.\n\n        Returns:\n            ee.Image: RGB visualization (uint8) or HSV image.\n        \"\"\"\n        phase = harmonic_coeffs.select(cos_band).atan2(harmonic_coeffs.select(sin_band))\n        amplitude = harmonic_coeffs.select(cos_band).hypot(\n            harmonic_coeffs.select(sin_band)\n        )\n\n        hsv = (\n            phase.unitScale(-math.pi, math.pi)\n            .addBands(amplitude.multiply(stretch_factor))\n            .addBands(self.composite)\n        )\n\n        if return_rgb:\n            return hsv.hsvToRgb().unitScale(0, 1).multiply(255).toByte()\n        else:\n            return hsv\n\n    def _fit_harmonics(self, harmonic_coeffs, image):\n        \"\"\"\n        Compute fitted values from harmonic coefficients and harmonic bands.\n\n        Args:\n            harmonic_coeffs (ee.Image): Coefficients image divided by 10000.\n            image (ee.Image): Image with harmonic bands.\n\n        Returns:\n            ee.Image: Image with fitted values.\n        \"\"\"\n        return (\n            image.select(self.independents)\n            .multiply(harmonic_coeffs)\n            .reduce(\"sum\")\n            .rename(\"fitted\")\n            .copyProperties(image, [\"system:time_start\"])\n        )\n\n    def get_fitted_harmonics(self, harmonic_coeffs):\n        \"\"\"\n        Compute fitted harmonic time series over the collection.\n\n        Args:\n            harmonic_coeffs (ee.Image): Coefficients image from get_harmonic_coeffs().\n\n        Returns:\n            ee.ImageCollection: Collection with fitted harmonic value as 'fitted' band.\n        \"\"\"\n        harmonic_coeffs_scaled = harmonic_coeffs.divide(10000)\n        harmonic_coll = self.image_collection.map(self._add_harmonics)\n\n        return harmonic_coll.map(\n            lambda img: self._fit_harmonics(harmonic_coeffs_scaled, img)\n        )\n</code></pre>"},{"location":"timeseries/#geeagri.timeseries.HarmonicRegression.__init__","title":"<code>__init__(self, image_collection, ref_date, band_name, order=1, omega=1)</code>  <code>special</code>","text":"<p>Initialize the HarmonicRegression object.</p> <p>Parameters:</p> Name Type Description Default <code>image_collection</code> <code>ee.ImageCollection</code> <p>Input image collection.</p> required <code>ref_date</code> <code>str or ee.Date</code> <p>Reference date to compute relative time.</p> required <code>band_name</code> <code>str</code> <p>Name of dependent variable band.</p> required <code>order</code> <code>int</code> <p>Number of harmonics (default 1).</p> <code>1</code> <code>omega</code> <code>float</code> <p>Base frequency multiplier (default 1).</p> <code>1</code> Source code in <code>geeagri/timeseries.py</code> <pre><code>def __init__(self, image_collection, ref_date, band_name, order=1, omega=1):\n    \"\"\"\n    Initialize the HarmonicRegression object.\n\n    Args:\n        image_collection (ee.ImageCollection): Input image collection.\n        ref_date (str or ee.Date): Reference date to compute relative time.\n        band_name (str): Name of dependent variable band.\n        order (int): Number of harmonics (default 1).\n        omega (float): Base frequency multiplier (default 1).\n    \"\"\"\n    self.image_collection = image_collection.select(band_name)\n    self.ref_date = ee.Date(ref_date) if isinstance(ref_date, str) else ref_date\n    self.band = band_name\n    self.order = order\n    self.omega = omega\n\n    # Names of independent variables: constant, cos_1, ..., sin_1, ...\n    self.independents = (\n        [\"constant\"]\n        + [f\"cos_{i}\" for i in range(1, order + 1)]\n        + [f\"sin_{i}\" for i in range(1, order + 1)]\n    )\n\n    # Precompute median composite of the selected band\n    self.composite = self.image_collection.median()\n</code></pre>"},{"location":"timeseries/#geeagri.timeseries.HarmonicRegression.get_fitted_harmonics","title":"<code>get_fitted_harmonics(self, harmonic_coeffs)</code>","text":"<p>Compute fitted harmonic time series over the collection.</p> <p>Parameters:</p> Name Type Description Default <code>harmonic_coeffs</code> <code>ee.Image</code> <p>Coefficients image from get_harmonic_coeffs().</p> required <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>Collection with fitted harmonic value as 'fitted' band.</p> Source code in <code>geeagri/timeseries.py</code> <pre><code>def get_fitted_harmonics(self, harmonic_coeffs):\n    \"\"\"\n    Compute fitted harmonic time series over the collection.\n\n    Args:\n        harmonic_coeffs (ee.Image): Coefficients image from get_harmonic_coeffs().\n\n    Returns:\n        ee.ImageCollection: Collection with fitted harmonic value as 'fitted' band.\n    \"\"\"\n    harmonic_coeffs_scaled = harmonic_coeffs.divide(10000)\n    harmonic_coll = self.image_collection.map(self._add_harmonics)\n\n    return harmonic_coll.map(\n        lambda img: self._fit_harmonics(harmonic_coeffs_scaled, img)\n    )\n</code></pre>"},{"location":"timeseries/#geeagri.timeseries.HarmonicRegression.get_harmonic_coeffs","title":"<code>get_harmonic_coeffs(self)</code>","text":"<p>Fit harmonic regression and return coefficients image.</p> <p>Returns:</p> Type Description <code>ee.Image</code> <p>Coefficients image with bands like _constant, _cos_1, etc. Source code in <code>geeagri/timeseries.py</code> <pre><code>def get_harmonic_coeffs(self):\n    \"\"\"\n    Fit harmonic regression and return coefficients image.\n\n    Returns:\n        ee.Image: Coefficients image with bands like &lt;band&gt;_constant, &lt;band&gt;_cos_1, etc.\n    \"\"\"\n    harmonic_coll = self.image_collection.map(self._add_harmonics)\n\n    regression = harmonic_coll.select(self.independents + [self.band]).reduce(\n        ee.Reducer.linearRegression(len(self.independents), 1)\n    )\n\n    coeffs = (\n        regression.select(\"coefficients\")\n        .arrayProject([0])\n        .arrayFlatten([self.independents])\n        .multiply(10000)\n        .toInt32()\n    )\n\n    new_names = [f\"{self.band}_{name}\" for name in self.independents]\n    return coeffs.rename(new_names)\n</code></pre>"},{"location":"timeseries/#geeagri.timeseries.HarmonicRegression.get_phase_amplitude","title":"<code>get_phase_amplitude(self, harmonic_coeffs, cos_band, sin_band, stretch_factor=1, return_rgb=True)</code>","text":"<p>Compute phase &amp; amplitude and optionally create RGB visualization.</p> <p>Parameters:</p> Name Type Description Default <code>harmonic_coeffs</code> <code>ee.Image</code> <p>Coefficients image from get_harmonic_coeffs().</p> required <code>cos_band</code> <code>str</code> <p>Name of cosine coefficient band.</p> required <code>sin_band</code> <code>str</code> <p>Name of sine coefficient band.</p> required <code>stretch_factor</code> <code>float</code> <p>Stretch amplitude to enhance contrast.</p> <code>1</code> <code>return_rgb</code> <code>bool</code> <p>If True, return RGB image; else return HSV image.</p> <code>True</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>RGB visualization (uint8) or HSV image.</p> Source code in <code>geeagri/timeseries.py</code> <pre><code>def get_phase_amplitude(\n    self, harmonic_coeffs, cos_band, sin_band, stretch_factor=1, return_rgb=True\n):\n    \"\"\"\n    Compute phase &amp; amplitude and optionally create RGB visualization.\n\n    Args:\n        harmonic_coeffs (ee.Image): Coefficients image from get_harmonic_coeffs().\n        cos_band (str): Name of cosine coefficient band.\n        sin_band (str): Name of sine coefficient band.\n        stretch_factor (float): Stretch amplitude to enhance contrast.\n        return_rgb (bool): If True, return RGB image; else return HSV image.\n\n    Returns:\n        ee.Image: RGB visualization (uint8) or HSV image.\n    \"\"\"\n    phase = harmonic_coeffs.select(cos_band).atan2(harmonic_coeffs.select(sin_band))\n    amplitude = harmonic_coeffs.select(cos_band).hypot(\n        harmonic_coeffs.select(sin_band)\n    )\n\n    hsv = (\n        phase.unitScale(-math.pi, math.pi)\n        .addBands(amplitude.multiply(stretch_factor))\n        .addBands(self.composite)\n    )\n\n    if return_rgb:\n        return hsv.hsvToRgb().unitScale(0, 1).multiply(255).toByte()\n    else:\n        return hsv\n</code></pre>"},{"location":"timeseries/#geeagri.timeseries.extract_timeseries_to_point","title":"<code>extract_timeseries_to_point(lat, lon, image_collection, start_date=None, end_date=None, band_names=None, scale=None, crs=None, crsTransform=None, out_csv=None)</code>","text":"<p>Extracts pixel time series from an ee.ImageCollection at a point.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude of the point.</p> required <code>lon</code> <code>float</code> <p>Longitude of the point.</p> required <code>image_collection</code> <code>ee.ImageCollection</code> <p>Image collection to sample.</p> required <code>start_date</code> <code>str</code> <p>Start date (e.g., '2020-01-01').</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date (e.g., '2020-12-31').</p> <code>None</code> <code>band_names</code> <code>list</code> <p>List of bands to extract.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Sampling scale in meters.</p> <code>None</code> <code>crs</code> <code>str</code> <p>Projection CRS. Defaults to image CRS.</p> <code>None</code> <code>crsTransform</code> <code>list</code> <p>CRS transform matrix (3x2 row-major). Overrides scale.</p> <code>None</code> <code>out_csv</code> <code>str</code> <p>File path to save CSV. If None, returns a DataFrame.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame or None</code> <p>Time series data if not exporting to CSV.</p> Source code in <code>geeagri/timeseries.py</code> <pre><code>def extract_timeseries_to_point(\n    lat,\n    lon,\n    image_collection,\n    start_date=None,\n    end_date=None,\n    band_names=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    out_csv=None,\n):\n    \"\"\"\n    Extracts pixel time series from an ee.ImageCollection at a point.\n\n    Args:\n        lat (float): Latitude of the point.\n        lon (float): Longitude of the point.\n        image_collection (ee.ImageCollection): Image collection to sample.\n        start_date (str, optional): Start date (e.g., '2020-01-01').\n        end_date (str, optional): End date (e.g., '2020-12-31').\n        band_names (list, optional): List of bands to extract.\n        scale (float, optional): Sampling scale in meters.\n        crs (str, optional): Projection CRS. Defaults to image CRS.\n        crsTransform (list, optional): CRS transform matrix (3x2 row-major). Overrides scale.\n        out_csv (str, optional): File path to save CSV. If None, returns a DataFrame.\n\n    Returns:\n        pd.DataFrame or None: Time series data if not exporting to CSV.\n    \"\"\"\n    import pandas as pd\n    from datetime import datetime\n\n    if not isinstance(image_collection, ee.ImageCollection):\n        raise ValueError(\"image_collection must be an instance of ee.ImageCollection.\")\n\n    property_names = image_collection.first().propertyNames().getInfo()\n    if \"system:time_start\" not in property_names:\n        raise ValueError(\"The image collection lacks the 'system:time_start' property.\")\n\n    point = ee.Geometry.Point([lon, lat])\n\n    try:\n        if start_date and end_date:\n            image_collection = image_collection.filterDate(start_date, end_date)\n        if band_names:\n            image_collection = image_collection.select(band_names)\n        image_collection = image_collection.filterBounds(point)\n    except Exception as e:\n        raise RuntimeError(f\"Error filtering image collection: {e}\")\n\n    try:\n        result = image_collection.getRegion(\n            geometry=point, scale=scale, crs=crs, crsTransform=crsTransform\n        ).getInfo()\n\n        result_df = pd.DataFrame(result[1:], columns=result[0])\n\n        if result_df.empty:\n            raise ValueError(\n                \"Extraction returned an empty DataFrame. Check your point, date range, or selected bands.\"\n            )\n\n        result_df[\"time\"] = result_df[\"time\"].apply(\n            lambda t: datetime.utcfromtimestamp(t / 1000)\n        )\n\n        if out_csv:\n            result_df.to_csv(out_csv, index=False)\n        else:\n            return result_df\n\n    except Exception as e:\n        raise RuntimeError(f\"Error extracting data: {e}.\")\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use geeagri in a project:</p> <pre><code>import geeagri\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print(\"Hello World!\")\n</pre> print(\"Hello World!\") <pre>Hello World!\n</pre>"}]}