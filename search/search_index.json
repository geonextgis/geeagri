{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geeagri","text":"<p>A Python package for agricultural monitoring and analysis using Google Earth Engine</p> <ul> <li>GitHub repo: https://github.com/geonextgis/geeagri</li> <li>Documentation: https://geonextgis.github.io/geeagri</li> <li>PyPI: https://pypi.org/project/geeagri</li> <li>Notebooks: https://github.com/geonextgis/geeagri/tree/main/docs/examples</li> <li>License: MIT</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>geeagri is a Python package that integrates the power of Google Earth Engine (GEE) with domain-specific agricultural analysis. It enables scalable processing, downloading, and visualization of satellite data for crop monitoring, yield estimation, and agro-environmental assessment.</p> <p>This package builds upon geospatial tools like <code>geemap</code> and simplifies workflows for scientists, researchers, and policymakers working in agriculture. Whether you're interested in vegetation monitoring, drought assessment, phenology extraction, or productivity mapping, geeagri offers tools and prebuilt pipelines to make your analysis easier and faster.</p> <p>geeagri is ideal for: - Researchers working with satellite-derived agricultural indicators. - Practitioners and analysts from development, environmental, and governmental organizations. - Students and educators looking to learn remote sensing for agriculture.</p> <p>For a complete list of examples and use cases, visit the notebooks section.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Extracting long-term time series data from GEE for both point and polygon geometries.</li> <li>Easy implementation of Harmonic Regression on vegetation or climate indices.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#geeagri.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>geeagri/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/geonextgis/geeagri/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geeagri could always use more documentation, whether as part of the official geeagri docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/geonextgis/geeagri/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geeagri for local development.</p> <ol> <li> <p>Fork the geeagri repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geeagri.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geeagri\n$ cd geeagri/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geeagri tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/geonextgis/geeagri/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"extract/","title":"extract module","text":"<p>Module for extracting data from Google Earth Engine.</p>"},{"location":"extract/#geeagri.extract.HarmonicRegression","title":"<code> HarmonicRegression        </code>","text":"<p>Perform harmonic regression on an Earth Engine ImageCollection.</p> <p>Attributes:</p> Name Type Description <code>image_collection</code> <code>ee.ImageCollection</code> <p>Input time series of selected band.</p> <code>ref_date</code> <code>ee.Date</code> <p>Reference date to calculate time.</p> <code>band</code> <code>str</code> <p>Name of dependent variable band.</p> <code>order</code> <code>int</code> <p>Number of harmonics.</p> <code>omega</code> <code>float</code> <p>Base frequency multiplier.</p> <code>independents</code> <code>List[str]</code> <p>Names of independent variable bands.</p> <code>composite</code> <code>ee.Image</code> <p>Median composite of the selected band.</p> Source code in <code>geeagri/extract.py</code> <pre><code>class HarmonicRegression:\n    \"\"\"\n    Perform harmonic regression on an Earth Engine ImageCollection.\n\n    Attributes:\n        image_collection (ee.ImageCollection): Input time series of selected band.\n        ref_date (ee.Date): Reference date to calculate time.\n        band (str): Name of dependent variable band.\n        order (int): Number of harmonics.\n        omega (float): Base frequency multiplier.\n        independents (List[str]): Names of independent variable bands.\n        composite (ee.Image): Median composite of the selected band.\n    \"\"\"\n\n    def __init__(self, image_collection, ref_date, band_name, order=1, omega=1):\n        \"\"\"\n        Initialize the HarmonicRegression object.\n\n        Args:\n            image_collection (ee.ImageCollection): Input image collection.\n            ref_date (str or ee.Date): Reference date to compute relative time.\n            band_name (str): Name of dependent variable band.\n            order (int): Number of harmonics (default 1).\n            omega (float): Base frequency multiplier (default 1).\n        \"\"\"\n        self.image_collection = image_collection.select(band_name)\n        self.ref_date = ee.Date(ref_date) if isinstance(ref_date, str) else ref_date\n        self.band = band_name\n        self.order = order\n        self.omega = omega\n\n        # Names of independent variables: constant, cos_1, ..., sin_1, ...\n        self.independents = (\n            [\"constant\"]\n            + [f\"cos_{i}\" for i in range(1, order + 1)]\n            + [f\"sin_{i}\" for i in range(1, order + 1)]\n        )\n\n        # Precompute median composite of the selected band\n        self.composite = self.image_collection.median()\n\n    def _add_time_unit(self, image):\n        \"\"\"\n        Add time difference in years from ref_date as band 't'.\n\n        Args:\n            image (ee.Image): Input image.\n\n        Returns:\n            ee.Image: Image with additional 't' band.\n        \"\"\"\n        dyear = ee.Number(image.date().difference(self.ref_date, \"year\"))\n        return image.addBands(ee.Image.constant(dyear).rename(\"t\").float())\n\n    def _add_harmonics(self, image):\n        \"\"\"\n        Add harmonic basis functions: constant, cos_i, sin_i bands.\n\n        Args:\n            image (ee.Image): Input image.\n\n        Returns:\n            ee.Image: Image with added harmonic bands.\n        \"\"\"\n        image = self._add_time_unit(image)\n        t = image.select(\"t\")\n\n        harmonic_bands = [ee.Image.constant(1).rename(\"constant\")]\n        for i in range(1, self.order + 1):\n            freq = ee.Number(i).multiply(self.omega).multiply(2 * math.pi)\n            harmonic_bands.append(t.multiply(freq).cos().rename(f\"cos_{i}\"))\n            harmonic_bands.append(t.multiply(freq).sin().rename(f\"sin_{i}\"))\n\n        return image.addBands(ee.Image(harmonic_bands))\n\n    def get_harmonic_coeffs(self):\n        \"\"\"\n        Fit harmonic regression and return coefficients image.\n\n        Returns:\n            ee.Image: Coefficients image with bands like &lt;band&gt;_constant, &lt;band&gt;_cos_1, etc.\n        \"\"\"\n        harmonic_coll = self.image_collection.map(self._add_harmonics)\n\n        regression = harmonic_coll.select(self.independents + [self.band]).reduce(\n            ee.Reducer.linearRegression(len(self.independents), 1)\n        )\n\n        coeffs = (\n            regression.select(\"coefficients\")\n            .arrayProject([0])\n            .arrayFlatten([self.independents])\n            .multiply(10000)\n            .toInt32()\n        )\n\n        new_names = [f\"{self.band}_{name}\" for name in self.independents]\n        return coeffs.rename(new_names)\n\n    def get_phase_amplitude(\n        self, harmonic_coeffs, cos_band, sin_band, stretch_factor=1, return_rgb=True\n    ):\n        \"\"\"\n        Compute phase &amp; amplitude and optionally create RGB visualization.\n\n        Args:\n            harmonic_coeffs (ee.Image): Coefficients image from get_harmonic_coeffs().\n            cos_band (str): Name of cosine coefficient band.\n            sin_band (str): Name of sine coefficient band.\n            stretch_factor (float): Stretch amplitude to enhance contrast.\n            return_rgb (bool): If True, return RGB image; else return HSV image.\n\n        Returns:\n            ee.Image: RGB visualization (uint8) or HSV image.\n        \"\"\"\n        phase = harmonic_coeffs.select(cos_band).atan2(harmonic_coeffs.select(sin_band))\n        amplitude = harmonic_coeffs.select(cos_band).hypot(\n            harmonic_coeffs.select(sin_band)\n        )\n\n        hsv = (\n            phase.unitScale(-math.pi, math.pi)\n            .addBands(amplitude.multiply(stretch_factor))\n            .addBands(self.composite)\n        )\n\n        if return_rgb:\n            return hsv.hsvToRgb().unitScale(0, 1).multiply(255).toByte()\n        else:\n            return hsv\n\n    def _fit_harmonics(self, harmonic_coeffs, image):\n        \"\"\"\n        Compute fitted values from harmonic coefficients and harmonic bands.\n\n        Args:\n            harmonic_coeffs (ee.Image): Coefficients image divided by 10000.\n            image (ee.Image): Image with harmonic bands.\n\n        Returns:\n            ee.Image: Image with fitted values.\n        \"\"\"\n        return (\n            image.select(self.independents)\n            .multiply(harmonic_coeffs)\n            .reduce(\"sum\")\n            .rename(\"fitted\")\n            .copyProperties(image, [\"system:time_start\"])\n        )\n\n    def get_fitted_harmonics(self, harmonic_coeffs):\n        \"\"\"\n        Compute fitted harmonic time series over the collection.\n\n        Args:\n            harmonic_coeffs (ee.Image): Coefficients image from get_harmonic_coeffs().\n\n        Returns:\n            ee.ImageCollection: Collection with fitted harmonic value as 'fitted' band.\n        \"\"\"\n        harmonic_coeffs_scaled = harmonic_coeffs.divide(10000)\n        harmonic_coll = self.image_collection.map(self._add_harmonics)\n\n        return harmonic_coll.map(\n            lambda img: self._fit_harmonics(harmonic_coeffs_scaled, img)\n        )\n</code></pre>"},{"location":"extract/#geeagri.extract.HarmonicRegression.__init__","title":"<code>__init__(self, image_collection, ref_date, band_name, order=1, omega=1)</code>  <code>special</code>","text":"<p>Initialize the HarmonicRegression object.</p> <p>Parameters:</p> Name Type Description Default <code>image_collection</code> <code>ee.ImageCollection</code> <p>Input image collection.</p> required <code>ref_date</code> <code>str or ee.Date</code> <p>Reference date to compute relative time.</p> required <code>band_name</code> <code>str</code> <p>Name of dependent variable band.</p> required <code>order</code> <code>int</code> <p>Number of harmonics (default 1).</p> <code>1</code> <code>omega</code> <code>float</code> <p>Base frequency multiplier (default 1).</p> <code>1</code> Source code in <code>geeagri/extract.py</code> <pre><code>def __init__(self, image_collection, ref_date, band_name, order=1, omega=1):\n    \"\"\"\n    Initialize the HarmonicRegression object.\n\n    Args:\n        image_collection (ee.ImageCollection): Input image collection.\n        ref_date (str or ee.Date): Reference date to compute relative time.\n        band_name (str): Name of dependent variable band.\n        order (int): Number of harmonics (default 1).\n        omega (float): Base frequency multiplier (default 1).\n    \"\"\"\n    self.image_collection = image_collection.select(band_name)\n    self.ref_date = ee.Date(ref_date) if isinstance(ref_date, str) else ref_date\n    self.band = band_name\n    self.order = order\n    self.omega = omega\n\n    # Names of independent variables: constant, cos_1, ..., sin_1, ...\n    self.independents = (\n        [\"constant\"]\n        + [f\"cos_{i}\" for i in range(1, order + 1)]\n        + [f\"sin_{i}\" for i in range(1, order + 1)]\n    )\n\n    # Precompute median composite of the selected band\n    self.composite = self.image_collection.median()\n</code></pre>"},{"location":"extract/#geeagri.extract.HarmonicRegression.get_fitted_harmonics","title":"<code>get_fitted_harmonics(self, harmonic_coeffs)</code>","text":"<p>Compute fitted harmonic time series over the collection.</p> <p>Parameters:</p> Name Type Description Default <code>harmonic_coeffs</code> <code>ee.Image</code> <p>Coefficients image from get_harmonic_coeffs().</p> required <p>Returns:</p> Type Description <code>ee.ImageCollection</code> <p>Collection with fitted harmonic value as 'fitted' band.</p> Source code in <code>geeagri/extract.py</code> <pre><code>def get_fitted_harmonics(self, harmonic_coeffs):\n    \"\"\"\n    Compute fitted harmonic time series over the collection.\n\n    Args:\n        harmonic_coeffs (ee.Image): Coefficients image from get_harmonic_coeffs().\n\n    Returns:\n        ee.ImageCollection: Collection with fitted harmonic value as 'fitted' band.\n    \"\"\"\n    harmonic_coeffs_scaled = harmonic_coeffs.divide(10000)\n    harmonic_coll = self.image_collection.map(self._add_harmonics)\n\n    return harmonic_coll.map(\n        lambda img: self._fit_harmonics(harmonic_coeffs_scaled, img)\n    )\n</code></pre>"},{"location":"extract/#geeagri.extract.HarmonicRegression.get_harmonic_coeffs","title":"<code>get_harmonic_coeffs(self)</code>","text":"<p>Fit harmonic regression and return coefficients image.</p> <p>Returns:</p> Type Description <code>ee.Image</code> <p>Coefficients image with bands like _constant, _cos_1, etc. Source code in <code>geeagri/extract.py</code> <pre><code>def get_harmonic_coeffs(self):\n    \"\"\"\n    Fit harmonic regression and return coefficients image.\n\n    Returns:\n        ee.Image: Coefficients image with bands like &lt;band&gt;_constant, &lt;band&gt;_cos_1, etc.\n    \"\"\"\n    harmonic_coll = self.image_collection.map(self._add_harmonics)\n\n    regression = harmonic_coll.select(self.independents + [self.band]).reduce(\n        ee.Reducer.linearRegression(len(self.independents), 1)\n    )\n\n    coeffs = (\n        regression.select(\"coefficients\")\n        .arrayProject([0])\n        .arrayFlatten([self.independents])\n        .multiply(10000)\n        .toInt32()\n    )\n\n    new_names = [f\"{self.band}_{name}\" for name in self.independents]\n    return coeffs.rename(new_names)\n</code></pre>"},{"location":"extract/#geeagri.extract.HarmonicRegression.get_phase_amplitude","title":"<code>get_phase_amplitude(self, harmonic_coeffs, cos_band, sin_band, stretch_factor=1, return_rgb=True)</code>","text":"<p>Compute phase &amp; amplitude and optionally create RGB visualization.</p> <p>Parameters:</p> Name Type Description Default <code>harmonic_coeffs</code> <code>ee.Image</code> <p>Coefficients image from get_harmonic_coeffs().</p> required <code>cos_band</code> <code>str</code> <p>Name of cosine coefficient band.</p> required <code>sin_band</code> <code>str</code> <p>Name of sine coefficient band.</p> required <code>stretch_factor</code> <code>float</code> <p>Stretch amplitude to enhance contrast.</p> <code>1</code> <code>return_rgb</code> <code>bool</code> <p>If True, return RGB image; else return HSV image.</p> <code>True</code> <p>Returns:</p> Type Description <code>ee.Image</code> <p>RGB visualization (uint8) or HSV image.</p> Source code in <code>geeagri/extract.py</code> <pre><code>def get_phase_amplitude(\n    self, harmonic_coeffs, cos_band, sin_band, stretch_factor=1, return_rgb=True\n):\n    \"\"\"\n    Compute phase &amp; amplitude and optionally create RGB visualization.\n\n    Args:\n        harmonic_coeffs (ee.Image): Coefficients image from get_harmonic_coeffs().\n        cos_band (str): Name of cosine coefficient band.\n        sin_band (str): Name of sine coefficient band.\n        stretch_factor (float): Stretch amplitude to enhance contrast.\n        return_rgb (bool): If True, return RGB image; else return HSV image.\n\n    Returns:\n        ee.Image: RGB visualization (uint8) or HSV image.\n    \"\"\"\n    phase = harmonic_coeffs.select(cos_band).atan2(harmonic_coeffs.select(sin_band))\n    amplitude = harmonic_coeffs.select(cos_band).hypot(\n        harmonic_coeffs.select(sin_band)\n    )\n\n    hsv = (\n        phase.unitScale(-math.pi, math.pi)\n        .addBands(amplitude.multiply(stretch_factor))\n        .addBands(self.composite)\n    )\n\n    if return_rgb:\n        return hsv.hsvToRgb().unitScale(0, 1).multiply(255).toByte()\n    else:\n        return hsv\n</code></pre>"},{"location":"extract/#geeagri.extract.extract_timeseries_to_point","title":"<code>extract_timeseries_to_point(lat, lon, image_collection, start_date=None, end_date=None, band_names=None, scale=None, crs=None, crsTransform=None, out_csv=None)</code>","text":"<p>Extracts pixel time series from an ee.ImageCollection at a point.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude of the point.</p> required <code>lon</code> <code>float</code> <p>Longitude of the point.</p> required <code>image_collection</code> <code>ee.ImageCollection</code> <p>Image collection to sample.</p> required <code>start_date</code> <code>str</code> <p>Start date (e.g., '2020-01-01').</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date (e.g., '2020-12-31').</p> <code>None</code> <code>band_names</code> <code>list</code> <p>List of bands to extract.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Sampling scale in meters.</p> <code>None</code> <code>crs</code> <code>str</code> <p>Projection CRS. Defaults to image CRS.</p> <code>None</code> <code>crsTransform</code> <code>list</code> <p>CRS transform matrix (3x2 row-major). Overrides scale.</p> <code>None</code> <code>out_csv</code> <code>str</code> <p>File path to save CSV. If None, returns a DataFrame.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame or None</code> <p>Time series data if not exporting to CSV.</p> Source code in <code>geeagri/extract.py</code> <pre><code>def extract_timeseries_to_point(\n    lat,\n    lon,\n    image_collection,\n    start_date=None,\n    end_date=None,\n    band_names=None,\n    scale=None,\n    crs=None,\n    crsTransform=None,\n    out_csv=None,\n):\n    \"\"\"\n    Extracts pixel time series from an ee.ImageCollection at a point.\n\n    Args:\n        lat (float): Latitude of the point.\n        lon (float): Longitude of the point.\n        image_collection (ee.ImageCollection): Image collection to sample.\n        start_date (str, optional): Start date (e.g., '2020-01-01').\n        end_date (str, optional): End date (e.g., '2020-12-31').\n        band_names (list, optional): List of bands to extract.\n        scale (float, optional): Sampling scale in meters.\n        crs (str, optional): Projection CRS. Defaults to image CRS.\n        crsTransform (list, optional): CRS transform matrix (3x2 row-major). Overrides scale.\n        out_csv (str, optional): File path to save CSV. If None, returns a DataFrame.\n\n    Returns:\n        pd.DataFrame or None: Time series data if not exporting to CSV.\n    \"\"\"\n    import pandas as pd\n    from datetime import datetime\n\n    if not isinstance(image_collection, ee.ImageCollection):\n        raise ValueError(\"image_collection must be an instance of ee.ImageCollection.\")\n\n    property_names = image_collection.first().propertyNames().getInfo()\n    if \"system:time_start\" not in property_names:\n        raise ValueError(\"The image collection lacks the 'system:time_start' property.\")\n\n    point = ee.Geometry.Point([lon, lat])\n\n    try:\n        if start_date and end_date:\n            image_collection = image_collection.filterDate(start_date, end_date)\n        if band_names:\n            image_collection = image_collection.select(band_names)\n        image_collection = image_collection.filterBounds(point)\n    except Exception as e:\n        raise RuntimeError(f\"Error filtering image collection: {e}\")\n\n    try:\n        result = image_collection.getRegion(\n            geometry=point, scale=scale, crs=crs, crsTransform=crsTransform\n        ).getInfo()\n\n        result_df = pd.DataFrame(result[1:], columns=result[0])\n\n        if result_df.empty:\n            raise ValueError(\n                \"Extraction returned an empty DataFrame. Check your point, date range, or selected bands.\"\n            )\n\n        result_df[\"time\"] = result_df[\"time\"].apply(\n            lambda t: datetime.utcfromtimestamp(t / 1000)\n        )\n\n        if out_csv:\n            result_df.to_csv(out_csv, index=False)\n        else:\n            return result_df\n\n    except Exception as e:\n        raise RuntimeError(f\"Error extracting data: {e}.\")\n</code></pre>"},{"location":"extract/#geeagri.extract.extract_timeseries_to_polygon","title":"<code>extract_timeseries_to_polygon(polygon, image_collection, start_date=None, end_date=None, band_names=None, scale=None, crs=None, reducer='MEAN', out_csv=None)</code>","text":"<p>Extracts time series statistics over a polygon from an ee.ImageCollection.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>ee.Geometry.Polygon</code> <p>Polygon geometry.</p> required <code>image_collection</code> <code>ee.ImageCollection</code> <p>Image collection to sample.</p> required <code>start_date</code> <code>str</code> <p>Start date (e.g., '2020-01-01').</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date (e.g., '2020-12-31').</p> <code>None</code> <code>band_names</code> <code>list</code> <p>List of bands to extract.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Sampling scale in meters.</p> <code>None</code> <code>crs</code> <code>str</code> <p>Projection CRS. Defaults to image CRS.</p> <code>None</code> <code>reducer</code> <code>str or ee.Reducer</code> <p>Name of reducer or ee.Reducer instance.</p> <code>'MEAN'</code> <code>out_csv</code> <code>str</code> <p>File path to save CSV. If None, returns a DataFrame.</p> <code>None</code> <p>Returns:</p> Type Description <code>pd.DataFrame or None</code> <p>Time series data if not exporting to CSV.</p> Source code in <code>geeagri/extract.py</code> <pre><code>def extract_timeseries_to_polygon(\n    polygon,\n    image_collection,\n    start_date=None,\n    end_date=None,\n    band_names=None,\n    scale=None,\n    crs=None,\n    reducer=\"MEAN\",\n    out_csv=None,\n):\n    \"\"\"\n    Extracts time series statistics over a polygon from an ee.ImageCollection.\n\n    Args:\n        polygon (ee.Geometry.Polygon): Polygon geometry.\n        image_collection (ee.ImageCollection): Image collection to sample.\n        start_date (str, optional): Start date (e.g., '2020-01-01').\n        end_date (str, optional): End date (e.g., '2020-12-31').\n        band_names (list, optional): List of bands to extract.\n        scale (float, optional): Sampling scale in meters.\n        crs (str, optional): Projection CRS. Defaults to image CRS.\n        reducer (str or ee.Reducer): Name of reducer or ee.Reducer instance.\n        out_csv (str, optional): File path to save CSV. If None, returns a DataFrame.\n\n    Returns:\n        pd.DataFrame or None: Time series data if not exporting to CSV.\n    \"\"\"\n    import pandas as pd\n    from datetime import datetime\n\n    if not isinstance(image_collection, ee.ImageCollection):\n        raise ValueError(\"image_collection must be an instance of ee.ImageCollection.\")\n    if not isinstance(polygon, ee.Geometry):\n        raise ValueError(\"polygon must be an instance of ee.Geometry.\")\n\n    # Allowed reducers\n    allowed_statistics = {\n        \"COUNT\": ee.Reducer.count(),\n        \"MEAN\": ee.Reducer.mean(),\n        \"MEAN_UNWEIGHTED\": ee.Reducer.mean().unweighted(),\n        \"MAXIMUM\": ee.Reducer.max(),\n        \"MEDIAN\": ee.Reducer.median(),\n        \"MINIMUM\": ee.Reducer.min(),\n        \"MODE\": ee.Reducer.mode(),\n        \"STD\": ee.Reducer.stdDev(),\n        \"MIN_MAX\": ee.Reducer.minMax(),\n        \"SUM\": ee.Reducer.sum(),\n        \"VARIANCE\": ee.Reducer.variance(),\n    }\n\n    # Get reducer from string or use directly\n    if isinstance(reducer, str):\n        reducer_upper = reducer.upper()\n        if reducer_upper not in allowed_statistics:\n            raise ValueError(\n                f\"Reducer '{reducer}' not supported. Choose from: {list(allowed_statistics.keys())}\"\n            )\n        reducer = allowed_statistics[reducer_upper]\n    elif not isinstance(reducer, ee.Reducer):\n        raise ValueError(\"reducer must be a string or an ee.Reducer instance.\")\n\n    # Filter dates and bands\n    if start_date and end_date:\n        image_collection = image_collection.filterDate(start_date, end_date)\n    if band_names:\n        image_collection = image_collection.select(band_names)\n\n    image_collection = image_collection.filterBounds(polygon)\n\n    def image_to_dict(image):\n        date = ee.Date(image.get(\"system:time_start\")).format(\"YYYY-MM-dd\")\n        stats = image.reduceRegion(\n            reducer=reducer, geometry=polygon, scale=scale, crs=crs, maxPixels=1e13\n        )\n        return ee.Feature(None, stats).set(\"time\", date)\n\n    stats_fc = image_collection.map(image_to_dict).filter(\n        ee.Filter.notNull(image_collection.first().bandNames())\n    )\n\n    try:\n        stats_list = stats_fc.getInfo()[\"features\"]\n    except Exception as e:\n        raise RuntimeError(f\"Error retrieving data from GEE: {e}\")\n\n    if not stats_list:\n        raise ValueError(\"No data returned for the given polygon and parameters.\")\n\n    records = []\n    for f in stats_list:\n        props = f[\"properties\"]\n        records.append(props)\n\n    df = pd.DataFrame(records)\n    df[\"time\"] = pd.to_datetime(df[\"time\"])\n    df.insert(0, \"time\", df.pop(\"time\"))\n\n    if out_csv:\n        df.to_csv(out_csv, index=False)\n    else:\n        return df\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"geeagri/","title":"geeagri module","text":"<p>Main module.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install geeagri, run this command in your terminal:</p> <pre><code>pip install geeagri\n</code></pre> <p>This is the preferred method to install geeagri, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install geeagri from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/geonextgis/geeagri\n</code></pre>"},{"location":"preprocessing/","title":"preprocessing module","text":"<p>Module for preprocessing Earth Observation data using Google Earth Engine.</p>"},{"location":"preprocessing/#geeagri.preprocessing.MeanCentering","title":"<code> MeanCentering        </code>","text":"<p>Mean-centers each band of an Earth Engine image.</p> <p>The transformation is computed as:</p> <p>$$ X_{centered} = X - \\mu $$</p> <p>Where:</p> <ul> <li>$X$: original pixel value</li> <li>$\\mu$: mean of the band computed over the given region</li> </ul> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>Input multi-band image to center.</p> required <code>region</code> <code>ee.Geometry</code> <p>Geometry over which statistics will be computed.</p> required <code>scale</code> <code>int</code> <p>Spatial resolution in meters. Defaults to 100.</p> <code>100</code> <code>max_pixels</code> <code>int</code> <p>Max pixels allowed in computation. Defaults to 1e9.</p> <code>1000000000</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If image or region is not an ee.Image or ee.Geometry.</p> Source code in <code>geeagri/preprocessing.py</code> <pre><code>class MeanCentering:\n    r\"\"\"\n    Mean-centers each band of an Earth Engine image.\n\n    The transformation is computed as:\n\n    $$\n    X_{centered} = X - \\mu\n    $$\n\n    Where:\n\n    - $X$: original pixel value\n    - $\\mu$: mean of the band computed over the given region\n\n    Args:\n        image (ee.Image): Input multi-band image to center.\n        region (ee.Geometry): Geometry over which statistics will be computed.\n        scale (int, optional): Spatial resolution in meters. Defaults to 100.\n        max_pixels (int, optional): Max pixels allowed in computation. Defaults to 1e9.\n\n    Raises:\n        TypeError: If image or region is not an ee.Image or ee.Geometry.\n    \"\"\"\n\n    def __init__(\n        self,\n        image: ee.Image,\n        region: ee.Geometry,\n        scale: int = 100,\n        max_pixels: int = int(1e9),\n    ):\n        if not isinstance(image, ee.Image):\n            raise TypeError(\"Expected 'image' to be of type ee.Image.\")\n        if not isinstance(region, ee.Geometry):\n            raise TypeError(\"Expected 'region' to be of type ee.Geometry.\")\n\n        self.image = image\n        self.region = region\n        self.scale = scale\n        self.max_pixels = max_pixels\n\n    def transform(self) -&gt; ee.Image:\n        \"\"\"\n        Applies mean-centering to each band of the image.\n\n        Returns:\n            ee.Image: The centered image with mean of each band subtracted.\n\n        Raises:\n            ValueError: If mean computation returns None or missing values.\n        \"\"\"\n        means = self.image.reduceRegion(\n            reducer=ee.Reducer.mean(),\n            geometry=self.region,\n            scale=self.scale,\n            bestEffort=True,\n            maxPixels=self.max_pixels,\n        )\n\n        if means is None:\n            raise ValueError(\"Mean computation failed \u2014 no valid pixels in the region.\")\n\n        bands = self.image.bandNames()\n\n        def center_band(band):\n            band = ee.String(band)\n            mean = ee.Number(means.get(band))\n            if mean is None:\n                raise ValueError(f\"Mean value not found for band: {band.getInfo()}\")\n            return self.image.select(band).subtract(mean).rename(band)\n\n        centered = bands.map(center_band)\n        return ee.ImageCollection(centered).toBands().rename(bands)\n</code></pre>"},{"location":"preprocessing/#geeagri.preprocessing.MeanCentering.transform","title":"<code>transform(self)</code>","text":"<p>Applies mean-centering to each band of the image.</p> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The centered image with mean of each band subtracted.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If mean computation returns None or missing values.</p> Source code in <code>geeagri/preprocessing.py</code> <pre><code>def transform(self) -&gt; ee.Image:\n    \"\"\"\n    Applies mean-centering to each band of the image.\n\n    Returns:\n        ee.Image: The centered image with mean of each band subtracted.\n\n    Raises:\n        ValueError: If mean computation returns None or missing values.\n    \"\"\"\n    means = self.image.reduceRegion(\n        reducer=ee.Reducer.mean(),\n        geometry=self.region,\n        scale=self.scale,\n        bestEffort=True,\n        maxPixels=self.max_pixels,\n    )\n\n    if means is None:\n        raise ValueError(\"Mean computation failed \u2014 no valid pixels in the region.\")\n\n    bands = self.image.bandNames()\n\n    def center_band(band):\n        band = ee.String(band)\n        mean = ee.Number(means.get(band))\n        if mean is None:\n            raise ValueError(f\"Mean value not found for band: {band.getInfo()}\")\n        return self.image.select(band).subtract(mean).rename(band)\n\n    centered = bands.map(center_band)\n    return ee.ImageCollection(centered).toBands().rename(bands)\n</code></pre>"},{"location":"preprocessing/#geeagri.preprocessing.MinMaxScaler","title":"<code> MinMaxScaler        </code>","text":"<p>Applies min-max normalization to each band of an Earth Engine image.</p> <p>The transformation is computed as:</p> <p>$$ X_\\text{scaled} = \\frac{X - \\min}{\\max - \\min} $$</p> <p>After clamping, $X_\\text{scaled} \\in [0, 1]$.</p> <p>Where:</p> <ul> <li>$\\min$, $\\max$: band-wise minimum and maximum values over the region.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>The input multi-band image.</p> required <code>region</code> <code>ee.Geometry</code> <p>The region over which to compute min and max.</p> required <code>scale</code> <code>int</code> <p>The spatial resolution in meters. Defaults to 100.</p> <code>100</code> <code>max_pixels</code> <code>int</code> <p>Max pixels allowed during reduction. Defaults to 1e9.</p> <code>1000000000</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If <code>image</code> is not an <code>ee.Image</code> or <code>region</code> is not an <code>ee.Geometry</code>.</p> Source code in <code>geeagri/preprocessing.py</code> <pre><code>class MinMaxScaler:\n    r\"\"\"\n    Applies min-max normalization to each band of an Earth Engine image.\n\n    The transformation is computed as:\n\n    $$\n    X_\\\\text{scaled} = \\\\frac{X - \\\\min}{\\\\max - \\\\min}\n    $$\n\n    After clamping, $X_\\\\text{scaled} \\\\in [0, 1]$.\n\n    Where:\n\n    - $\\min$, $\\max$: band-wise minimum and maximum values over the region.\n\n    Args:\n        image (ee.Image): The input multi-band image.\n        region (ee.Geometry): The region over which to compute min and max.\n        scale (int, optional): The spatial resolution in meters. Defaults to 100.\n        max_pixels (int, optional): Max pixels allowed during reduction. Defaults to 1e9.\n\n    Raises:\n        TypeError: If `image` is not an `ee.Image` or `region` is not an `ee.Geometry`.\n    \"\"\"\n\n    def __init__(\n        self,\n        image: ee.Image,\n        region: ee.Geometry,\n        scale: int = 100,\n        max_pixels: int = int(1e9),\n    ):\n        if not isinstance(image, ee.Image):\n            raise TypeError(\"Expected 'image' to be of type ee.Image.\")\n        if not isinstance(region, ee.Geometry):\n            raise TypeError(\"Expected 'region' to be of type ee.Geometry.\")\n\n        self.image = image\n        self.region = region\n        self.scale = scale\n        self.max_pixels = max_pixels\n\n    def transform(self) -&gt; ee.Image:\n        \"\"\"\n        Applies min-max scaling to each band, producing values in the range [0, 1].\n\n        Returns:\n            ee.Image: A scaled image with band values clamped between 0 and 1.\n\n        Raises:\n            ValueError: If min or max statistics are unavailable or reduction fails.\n        \"\"\"\n        stats = self.image.reduceRegion(\n            reducer=ee.Reducer.minMax(),\n            geometry=self.region,\n            scale=self.scale,\n            bestEffort=True,\n            maxPixels=self.max_pixels,\n        )\n\n        if stats is None:\n            raise ValueError(\n                \"MinMax reduction failed \u2014 possibly no valid pixels in region.\"\n            )\n\n        bands = self.image.bandNames()\n\n        def scale_band(band):\n            band = ee.String(band)\n            min_val = ee.Number(stats.get(band.cat(\"_min\")))\n            max_val = ee.Number(stats.get(band.cat(\"_max\")))\n            if min_val is None or max_val is None:\n                raise ValueError(f\"Missing min/max for band: {band.getInfo()}\")\n            scaled = (\n                self.image.select(band)\n                .subtract(min_val)\n                .divide(max_val.subtract(min_val))\n            )\n            return scaled.clamp(0, 1).rename(band)\n\n        scaled = bands.map(scale_band)\n        return ee.ImageCollection(scaled).toBands().rename(bands)\n</code></pre>"},{"location":"preprocessing/#geeagri.preprocessing.MinMaxScaler.transform","title":"<code>transform(self)</code>","text":"<p>Applies min-max scaling to each band, producing values in the range [0, 1].</p> <p>Returns:</p> Type Description <code>ee.Image</code> <p>A scaled image with band values clamped between 0 and 1.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If min or max statistics are unavailable or reduction fails.</p> Source code in <code>geeagri/preprocessing.py</code> <pre><code>def transform(self) -&gt; ee.Image:\n    \"\"\"\n    Applies min-max scaling to each band, producing values in the range [0, 1].\n\n    Returns:\n        ee.Image: A scaled image with band values clamped between 0 and 1.\n\n    Raises:\n        ValueError: If min or max statistics are unavailable or reduction fails.\n    \"\"\"\n    stats = self.image.reduceRegion(\n        reducer=ee.Reducer.minMax(),\n        geometry=self.region,\n        scale=self.scale,\n        bestEffort=True,\n        maxPixels=self.max_pixels,\n    )\n\n    if stats is None:\n        raise ValueError(\n            \"MinMax reduction failed \u2014 possibly no valid pixels in region.\"\n        )\n\n    bands = self.image.bandNames()\n\n    def scale_band(band):\n        band = ee.String(band)\n        min_val = ee.Number(stats.get(band.cat(\"_min\")))\n        max_val = ee.Number(stats.get(band.cat(\"_max\")))\n        if min_val is None or max_val is None:\n            raise ValueError(f\"Missing min/max for band: {band.getInfo()}\")\n        scaled = (\n            self.image.select(band)\n            .subtract(min_val)\n            .divide(max_val.subtract(min_val))\n        )\n        return scaled.clamp(0, 1).rename(band)\n\n    scaled = bands.map(scale_band)\n    return ee.ImageCollection(scaled).toBands().rename(bands)\n</code></pre>"},{"location":"preprocessing/#geeagri.preprocessing.RobustScaler","title":"<code> RobustScaler        </code>","text":"<p>Applies robust scaling to each band of an Earth Engine image using percentiles, which reduces the influence of outliers compared to min-max scaling.</p> <p>The transformation is computed as:</p> <p>$$ X_\\text{scaled} = \\frac{X - P_{\\text{lower}}}{P_{\\text{upper}} - P_{\\text{lower}}} $$</p> <p>After clamping, $X_\\text{scaled} \\in [0, 1]$.</p> <p>Where:</p> <ul> <li>$X$: original pixel value</li> <li>$P_{\\text{lower}}$: lower percentile value (e.g., 25th percentile)</li> <li>$P_{\\text{upper}}$: upper percentile value (e.g., 75th percentile)</li> </ul> <p>This method is particularly useful when the image contains outliers or skewed distributions.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>The input multi-band image.</p> required <code>region</code> <code>ee.Geometry</code> <p>Geometry over which percentiles are computed.</p> required <code>scale</code> <code>int</code> <p>Spatial resolution in meters for computation.</p> <code>100</code> <code>lower</code> <code>int</code> <p>Lower percentile to use (default: 25).</p> <code>25</code> <code>upper</code> <code>int</code> <p>Upper percentile to use (default: 75).</p> <code>75</code> <code>max_pixels</code> <code>int</code> <p>Maximum number of pixels allowed for region reduction.</p> <code>1000000000</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If <code>image</code> is not an <code>ee.Image</code> or <code>region</code> is not an <code>ee.Geometry</code>.</p> Source code in <code>geeagri/preprocessing.py</code> <pre><code>class RobustScaler:\n    r\"\"\"\n    Applies robust scaling to each band of an Earth Engine image using percentiles,\n    which reduces the influence of outliers compared to min-max scaling.\n\n    The transformation is computed as:\n\n    $$\n    X_\\\\text{scaled} = \\\\frac{X - P_{\\\\text{lower}}}{P_{\\\\text{upper}} - P_{\\\\text{lower}}}\n    $$\n\n    After clamping, $X_\\\\text{scaled} \\\\in [0, 1]$.\n\n    Where:\n\n    - $X$: original pixel value\n    - $P_{\\\\text{lower}}$: lower percentile value (e.g., 25th percentile)\n    - $P_{\\\\text{upper}}$: upper percentile value (e.g., 75th percentile)\n\n    This method is particularly useful when the image contains outliers or skewed distributions.\n\n    Args:\n        image (ee.Image): The input multi-band image.\n        region (ee.Geometry): Geometry over which percentiles are computed.\n        scale (int): Spatial resolution in meters for computation.\n        lower (int): Lower percentile to use (default: 25).\n        upper (int): Upper percentile to use (default: 75).\n        max_pixels (int): Maximum number of pixels allowed for region reduction.\n\n    Raises:\n        TypeError: If `image` is not an `ee.Image` or `region` is not an `ee.Geometry`.\n    \"\"\"\n\n    def __init__(\n        self,\n        image: ee.Image,\n        region: ee.Geometry,\n        scale: int = 100,\n        lower: int = 25,\n        upper: int = 75,\n        max_pixels: int = int(1e9),\n    ):\n        if not isinstance(image, ee.Image):\n            raise TypeError(\"Expected 'image' to be of type ee.Image.\")\n        if not isinstance(region, ee.Geometry):\n            raise TypeError(\"Expected 'region' to be of type ee.Geometry.\")\n        if not (0 &lt;= lower &lt; upper &lt;= 100):\n            raise ValueError(\"Percentiles must satisfy 0 &lt;= lower &lt; upper &lt;= 100.\")\n\n        self.image = image\n        self.region = region\n        self.scale = scale\n        self.lower = lower\n        self.upper = upper\n        self.max_pixels = max_pixels\n\n    def transform(self) -&gt; ee.Image:\n        \"\"\"\n        Applies percentile-based scaling to each band in the image.\n        Values are scaled to the [0, 1] range and clamped.\n\n        Returns:\n            ee.Image: The scaled image with values between 0 and 1.\n\n        Raises:\n            ValueError: If percentile reduction fails.\n        \"\"\"\n        bands = self.image.bandNames()\n        percentiles = self.image.reduceRegion(\n            reducer=ee.Reducer.percentile([self.lower, self.upper]),\n            geometry=self.region,\n            scale=self.scale,\n            bestEffort=True,\n            maxPixels=self.max_pixels,\n        )\n\n        if percentiles is None:\n            raise ValueError(\"Percentile computation failed.\")\n\n        def scale_band(band):\n            band = ee.String(band)\n            p_min = ee.Number(percentiles.get(band.cat(f\"_p{self.lower}\")))\n            p_max = ee.Number(percentiles.get(band.cat(f\"_p{self.upper}\")))\n            if p_min is None or p_max is None:\n                raise ValueError(\n                    f\"Missing percentile values for band: {band.getInfo()}\"\n                )\n\n            scaled = (\n                self.image.select(band).subtract(p_min).divide(p_max.subtract(p_min))\n            )\n            return scaled.clamp(0, 1).rename(band)\n\n        scaled = bands.map(scale_band)\n        return ee.ImageCollection(scaled).toBands().rename(bands)\n</code></pre>"},{"location":"preprocessing/#geeagri.preprocessing.RobustScaler.transform","title":"<code>transform(self)</code>","text":"<p>Applies percentile-based scaling to each band in the image. Values are scaled to the [0, 1] range and clamped.</p> <p>Returns:</p> Type Description <code>ee.Image</code> <p>The scaled image with values between 0 and 1.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If percentile reduction fails.</p> Source code in <code>geeagri/preprocessing.py</code> <pre><code>def transform(self) -&gt; ee.Image:\n    \"\"\"\n    Applies percentile-based scaling to each band in the image.\n    Values are scaled to the [0, 1] range and clamped.\n\n    Returns:\n        ee.Image: The scaled image with values between 0 and 1.\n\n    Raises:\n        ValueError: If percentile reduction fails.\n    \"\"\"\n    bands = self.image.bandNames()\n    percentiles = self.image.reduceRegion(\n        reducer=ee.Reducer.percentile([self.lower, self.upper]),\n        geometry=self.region,\n        scale=self.scale,\n        bestEffort=True,\n        maxPixels=self.max_pixels,\n    )\n\n    if percentiles is None:\n        raise ValueError(\"Percentile computation failed.\")\n\n    def scale_band(band):\n        band = ee.String(band)\n        p_min = ee.Number(percentiles.get(band.cat(f\"_p{self.lower}\")))\n        p_max = ee.Number(percentiles.get(band.cat(f\"_p{self.upper}\")))\n        if p_min is None or p_max is None:\n            raise ValueError(\n                f\"Missing percentile values for band: {band.getInfo()}\"\n            )\n\n        scaled = (\n            self.image.select(band).subtract(p_min).divide(p_max.subtract(p_min))\n        )\n        return scaled.clamp(0, 1).rename(band)\n\n    scaled = bands.map(scale_band)\n    return ee.ImageCollection(scaled).toBands().rename(bands)\n</code></pre>"},{"location":"preprocessing/#geeagri.preprocessing.StandardScaler","title":"<code> StandardScaler        </code>","text":"<p>Standardizes each band of an Earth Engine image using z-score normalization.</p> <p>The transformation is computed as:</p> <p>$$ X_\\text{standardized} = \\frac{X - \\mu}{\\sigma} $$</p> <p>Where:</p> <ul> <li>$X$: original pixel value</li> <li>$\\mu$: mean of the band over the specified region</li> <li>$\\sigma$: standard deviation of the band over the specified region</li> </ul> <p>This transformation results in a standardized image where each band has zero mean and unit variance (approximately), assuming normally distributed values.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ee.Image</code> <p>The input multi-band image to be standardized.</p> required <code>region</code> <code>ee.Geometry</code> <p>The geographic region over which to compute the statistics.</p> required <code>scale</code> <code>int</code> <p>Spatial resolution (in meters) to use for region reduction. Defaults to 100.</p> <code>100</code> <code>max_pixels</code> <code>int</code> <p>Maximum number of pixels allowed in reduction. Defaults to 1e9.</p> <code>1000000000</code> <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If <code>image</code> is not an <code>ee.Image</code> or <code>region</code> is not an <code>ee.Geometry</code>.</p> Source code in <code>geeagri/preprocessing.py</code> <pre><code>class StandardScaler:\n    r\"\"\"\n    Standardizes each band of an Earth Engine image using z-score normalization.\n\n    The transformation is computed as:\n\n    $$\n    X_\\\\text{standardized} = \\\\frac{X - \\\\mu}{\\\\sigma}\n    $$\n\n    Where:\n\n    - $X$: original pixel value\n    - $\\mu$: mean of the band over the specified region\n    - $\\sigma$: standard deviation of the band over the specified region\n\n    This transformation results in a standardized image where each band has\n    zero mean and unit variance (approximately), assuming normally distributed values.\n\n    Args:\n        image (ee.Image): The input multi-band image to be standardized.\n        region (ee.Geometry): The geographic region over which to compute the statistics.\n        scale (int, optional): Spatial resolution (in meters) to use for region reduction. Defaults to 100.\n        max_pixels (int, optional): Maximum number of pixels allowed in reduction. Defaults to 1e9.\n\n    Raises:\n        TypeError: If `image` is not an `ee.Image` or `region` is not an `ee.Geometry`.\n    \"\"\"\n\n    def __init__(\n        self,\n        image: ee.Image,\n        region: ee.Geometry,\n        scale: int = 100,\n        max_pixels: int = int(1e9),\n    ):\n        if not isinstance(image, ee.Image):\n            raise TypeError(\"Expected 'image' to be of type ee.Image.\")\n        if not isinstance(region, ee.Geometry):\n            raise TypeError(\"Expected 'region' to be of type ee.Geometry.\")\n\n        self.image = image\n        self.region = region\n        self.scale = scale\n        self.max_pixels = max_pixels\n\n    def transform(self) -&gt; ee.Image:\n        \"\"\"\n        Applies z-score normalization to each band.\n\n        Returns:\n            ee.Image: Standardized image with zero mean and unit variance.\n\n        Raises:\n            ValueError: If statistics could not be computed.\n        \"\"\"\n        means = self.image.reduceRegion(\n            reducer=ee.Reducer.mean(),\n            geometry=self.region,\n            scale=self.scale,\n            bestEffort=True,\n            maxPixels=self.max_pixels,\n        )\n        stds = self.image.reduceRegion(\n            reducer=ee.Reducer.stdDev(),\n            geometry=self.region,\n            scale=self.scale,\n            bestEffort=True,\n            maxPixels=self.max_pixels,\n        )\n\n        if means is None or stds is None:\n            raise ValueError(\n                \"Statistic computation failed \u2014 check if region has valid pixels.\"\n            )\n\n        bands = self.image.bandNames()\n\n        def scale_band(band):\n            band = ee.String(band)\n            mean = ee.Number(means.get(band))\n            std = ee.Number(stds.get(band))\n            if mean is None or std is None:\n                raise ValueError(f\"Missing stats for band: {band.getInfo()}\")\n            return self.image.select(band).subtract(mean).divide(std).rename(band)\n\n        scaled = bands.map(scale_band)\n        return ee.ImageCollection(scaled).toBands().rename(bands)\n</code></pre>"},{"location":"preprocessing/#geeagri.preprocessing.StandardScaler.transform","title":"<code>transform(self)</code>","text":"<p>Applies z-score normalization to each band.</p> <p>Returns:</p> Type Description <code>ee.Image</code> <p>Standardized image with zero mean and unit variance.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If statistics could not be computed.</p> Source code in <code>geeagri/preprocessing.py</code> <pre><code>def transform(self) -&gt; ee.Image:\n    \"\"\"\n    Applies z-score normalization to each band.\n\n    Returns:\n        ee.Image: Standardized image with zero mean and unit variance.\n\n    Raises:\n        ValueError: If statistics could not be computed.\n    \"\"\"\n    means = self.image.reduceRegion(\n        reducer=ee.Reducer.mean(),\n        geometry=self.region,\n        scale=self.scale,\n        bestEffort=True,\n        maxPixels=self.max_pixels,\n    )\n    stds = self.image.reduceRegion(\n        reducer=ee.Reducer.stdDev(),\n        geometry=self.region,\n        scale=self.scale,\n        bestEffort=True,\n        maxPixels=self.max_pixels,\n    )\n\n    if means is None or stds is None:\n        raise ValueError(\n            \"Statistic computation failed \u2014 check if region has valid pixels.\"\n        )\n\n    bands = self.image.bandNames()\n\n    def scale_band(band):\n        band = ee.String(band)\n        mean = ee.Number(means.get(band))\n        std = ee.Number(stds.get(band))\n        if mean is None or std is None:\n            raise ValueError(f\"Missing stats for band: {band.getInfo()}\")\n        return self.image.select(band).subtract(mean).divide(std).rename(band)\n\n    scaled = bands.map(scale_band)\n    return ee.ImageCollection(scaled).toBands().rename(bands)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use geeagri in a project:</p> <pre><code>import geeagri\n</code></pre>"},{"location":"examples/image_scaling/","title":"Image scaling","text":"<p>Uncomment the following line to install the latest version of geeagri if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geeagri\n</pre> # !pip install -U geeagri In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nfrom geeagri.preprocessing import (\n    MeanCentering,\n    StandardScaler,\n    MinMaxScaler,\n    RobustScaler,\n)\n</pre> import ee import geemap from geeagri.preprocessing import (     MeanCentering,     StandardScaler,     MinMaxScaler,     RobustScaler, ) In\u00a0[\u00a0]: Copied! <pre># ee.Authenticate()\n# ee.Initialize(project='your-project-id')\n\nMap = geemap.Map()\nMap\n</pre> # ee.Authenticate() # ee.Initialize(project='your-project-id')  Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>bbox = [-120.398369, 37.006574, -120.208168, 37.101924]\nregion = ee.Geometry.BBox(*bbox)\nregion_style = {\"color\": \"red\", \"width\": 1}\nMap.addLayer(region, region_style, \"Region\")\nMap.centerObject(region, 12)\n</pre> bbox = [-120.398369, 37.006574, -120.208168, 37.101924] region = ee.Geometry.BBox(*bbox) region_style = {\"color\": \"red\", \"width\": 1} Map.addLayer(region, region_style, \"Region\") Map.centerObject(region, 12) In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\")\n    .filterBounds(region)\n    .filterDate(\"2024-01-01\", \"2025-01-01\")\n    .filterMetadata(\"CLOUDY_PIXEL_PERCENTAGE\", \"less_than\", 10)\n    .select([\"B8\", \"B4\", \"B3\"])\n    .median()\n    .multiply(0.0001)\n    .clip(region)\n)\n\nimage_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 0.3}\n\nMap.addLayer(image, image_vis, \"Sentinel 2 FCC\")\n</pre> image = (     ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\")     .filterBounds(region)     .filterDate(\"2024-01-01\", \"2025-01-01\")     .filterMetadata(\"CLOUDY_PIXEL_PERCENTAGE\", \"less_than\", 10)     .select([\"B8\", \"B4\", \"B3\"])     .median()     .multiply(0.0001)     .clip(region) )  image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 0.3}  Map.addLayer(image, image_vis, \"Sentinel 2 FCC\") In\u00a0[\u00a0]: Copied! <pre>scaler = MeanCentering(image, region)\ncentered_image = scaler.transform()\n\n# Adjust visualization range around 0 to reflect centered values\ncentered_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": -0.09, \"max\": 0.09}\nMap.addLayer(centered_image, centered_image_vis, \"MeanCentering\")\n</pre> scaler = MeanCentering(image, region) centered_image = scaler.transform()  # Adjust visualization range around 0 to reflect centered values centered_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": -0.09, \"max\": 0.09} Map.addLayer(centered_image, centered_image_vis, \"MeanCentering\") In\u00a0[\u00a0]: Copied! <pre>scaler = MinMaxScaler(image, region)\nscaled_image = scaler.transform()\n\nscaled_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 1}\nMap.addLayer(scaled_image, scaled_image_vis, \"MinMaxScaler\")\n</pre> scaler = MinMaxScaler(image, region) scaled_image = scaler.transform()  scaled_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 1} Map.addLayer(scaled_image, scaled_image_vis, \"MinMaxScaler\") In\u00a0[\u00a0]: Copied! <pre>scaler = StandardScaler(image, region)\nstandardized_image = scaler.transform()\n\n# You may want to visualize within a reasonable range\nstandardized_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": -2, \"max\": 2}\nMap.addLayer(standardized_image, standardized_image_vis, \"StandardScaler\")\n</pre> scaler = StandardScaler(image, region) standardized_image = scaler.transform()  # You may want to visualize within a reasonable range standardized_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": -2, \"max\": 2} Map.addLayer(standardized_image, standardized_image_vis, \"StandardScaler\") In\u00a0[\u00a0]: Copied! <pre>scaler = RobustScaler(image, region, lower=1, upper=99)\nscaled_image = scaler.transform()\n\nscaled_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 1}\nMap.addLayer(scaled_image, scaled_image_vis, \"RobustScaler\")\n</pre> scaler = RobustScaler(image, region, lower=1, upper=99) scaled_image = scaler.transform()  scaled_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 1} Map.addLayer(scaled_image, scaled_image_vis, \"RobustScaler\") <p>\ud83d\udca1 Tips for Efficient Processing</p> <ul> <li><p>Increase the <code>scale</code> parameter to reduce computation time. Calculating statistics (e.g., mean, percentiles) over high-resolution images (like Sentinel-2 at 10\u202fm) can be time-consuming or cause timeouts. Try <code>scale=100</code> or higher when possible.</p> </li> <li><p>Use simpler geometries. Avoid complex shapes like administrative boundaries or large regions. Instead, use simplified or bounding box geometries.</p> </li> <li><p>You can simplify any geometry by converting it to a bounding rectangle using:</p> <pre>simple_region = complex_region.bounds()\n</pre> <p>This can drastically speed up reduceRegion operations while still capturing spatial context.</p> </li> </ul>"},{"location":"examples/image_scaling/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"examples/image_scaling/#initialize-a-map-object","title":"Initialize a Map object\u00b6","text":"<p>Authenticate and initialize Earth Engine. If it doesn't work, specify a project name</p>"},{"location":"examples/image_scaling/#import-region-of-interest","title":"Import region of interest\u00b6","text":""},{"location":"examples/image_scaling/#load-sentinel-2-data-and-create-a-median-composite","title":"Load Sentinel-2 Data and Create a Median Composite\u00b6","text":""},{"location":"examples/image_scaling/#meancentering","title":"MeanCentering\u00b6","text":"<p>Subtracts the mean from each band to center values around zero:</p> <p>$$ X_\\text{centered} = X - \\mu $$</p> <p>Where:</p> <ul> <li>$X$: original pixel value</li> <li>$\\mu$: mean of the band computed over the given region</li> </ul>"},{"location":"examples/image_scaling/#minmaxscaler","title":"MinMaxScaler\u00b6","text":"<p>Normalizes each band using the min and max values over the region:</p> <p>$$ X_\\text{scaled} = \\frac{X - \\min}{\\max - \\min}, \\quad X_\\text{scaled} \\in [0, 1] $$</p> <p>Where:</p> <ul> <li>$\\min$, $\\max$: band-wise minimum and maximum values over the region.</li> </ul>"},{"location":"examples/image_scaling/#standardscaler","title":"StandardScaler\u00b6","text":"<p>Standardizes each band using z-score normalization (mean and standard deviation):</p> <p>$$ X_\\text{standardized} = \\frac{X - \\mu}{\\sigma} $$</p> <p>Where:</p> <ul> <li>$X$: original pixel value</li> <li>$\\mu$: mean of the band over the specified region</li> <li>$\\sigma$: standard deviation of the band over the specified region</li> </ul>"},{"location":"examples/image_scaling/#robustscaler","title":"RobustScaler\u00b6","text":"<p>Scales each band using robust percentiles (e.g., 1st and 99th) to reduce the influence of outliers:</p> <p>$$ X_\\text{scaled} = \\frac{X - P_\\text{lower}}{P_\\text{upper} - P_\\text{lower}}, \\quad X_\\text{scaled} \\in [0, 1] $$</p> <p>Where:</p> <ul> <li>$X$: original pixel value</li> <li>$P_{\\\\text{lower}}$: lower percentile value (e.g., 25th percentile)</li> <li>$P_{\\\\text{upper}}$: upper percentile value (e.g., 75th percentile)</li> </ul>"},{"location":"examples/pca/","title":"Pca","text":"<p>Uncomment the following line to install the latest version of geeagri if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install -U geeagri\n</pre> # !pip install -U geeagri In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nfrom geeagri.analysis import PCA\n</pre> import ee import geemap from geeagri.analysis import PCA In\u00a0[\u00a0]: Copied! <pre># ee.Authenticate()\n# ee.Initialize(project='your-project-id')\n\nMap = geemap.Map(basemap=\"SATELLITE\")\nMap\n</pre> # ee.Authenticate() # ee.Initialize(project='your-project-id')  Map = geemap.Map(basemap=\"SATELLITE\") Map In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection(\"projects/sat-io/open-datasets/PLANET/TANAGER_HYPERSPECTRAL\")\n    .filter(ee.Filter.eq(\"system:index\", \"20250516_181930_35_4001\"))\n    .first()\n    .select(\"B.*\")\n)\n\n\nvis = {\n    \"opacity\": 1,\n    \"bands\": [\"B100\", \"B060\", \"B040\"],\n    \"min\": 14.014482498168945,\n    \"max\": 147.4988250732422,\n    \"gamma\": 1,\n}\n\nMap.centerObject(image.geometry())\nMap.addLayer(image, vis, \"Tanager Sample\")\n</pre> image = (     ee.ImageCollection(\"projects/sat-io/open-datasets/PLANET/TANAGER_HYPERSPECTRAL\")     .filter(ee.Filter.eq(\"system:index\", \"20250516_181930_35_4001\"))     .first()     .select(\"B.*\") )   vis = {     \"opacity\": 1,     \"bands\": [\"B100\", \"B060\", \"B040\"],     \"min\": 14.014482498168945,     \"max\": 147.4988250732422,     \"gamma\": 1, }  Map.centerObject(image.geometry()) Map.addLayer(image, vis, \"Tanager Sample\") In\u00a0[\u00a0]: Copied! <pre>pca = PCA(image, region=image.geometry(), scale=100)\ncentered_image = pca.centered_image\n\nvis = {\n    \"opacity\": 1,\n    \"bands\": [\"B100\", \"B060\", \"B040\"],\n    \"min\": -73,\n    \"max\": 85,\n    \"gamma\": 1,\n}\n\nMap.centerObject(centered_image.geometry())\nMap.addLayer(centered_image, vis, \"Centered Image\")\n</pre> pca = PCA(image, region=image.geometry(), scale=100) centered_image = pca.centered_image  vis = {     \"opacity\": 1,     \"bands\": [\"B100\", \"B060\", \"B040\"],     \"min\": -73,     \"max\": 85,     \"gamma\": 1, }  Map.centerObject(centered_image.geometry()) Map.addLayer(centered_image, vis, \"Centered Image\") In\u00a0[\u00a0]: Copied! <pre># pcs = pca.get_principal_components()\n</pre> # pcs = pca.get_principal_components() In\u00a0[\u00a0]: Copied! <pre>arrays = centered_image.toArray()\ncovar = arrays.reduceRegion(\n    reducer=ee.Reducer.centeredCovariance(),\n    geometry=image.geometry(),\n    scale=100,\n    maxPixels=1e9,\n)\n</pre> arrays = centered_image.toArray() covar = arrays.reduceRegion(     reducer=ee.Reducer.centeredCovariance(),     geometry=image.geometry(),     scale=100,     maxPixels=1e9, ) In\u00a0[\u00a0]: Copied! <pre>covar_array = ee.Array(covar.get(\"array\"))\neigens = covar_array.eigen()\n</pre> covar_array = ee.Array(covar.get(\"array\")) eigens = covar_array.eigen() In\u00a0[\u00a0]: Copied! <pre>eigens\n</pre> eigens In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\")\n    .filterBounds(region)\n    .filterDate(\"2024-01-01\", \"2025-01-01\")\n    .filterMetadata(\"CLOUDY_PIXEL_PERCENTAGE\", \"less_than\", 10)\n    .select([\"B8\", \"B4\", \"B3\"])\n    .median()\n    .multiply(0.0001)\n    .clip(region)\n)\n\nimage_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 0.3}\n\nMap.addLayer(image, image_vis, \"Sentinel 2 FCC\")\n</pre> image = (     ee.ImageCollection(\"COPERNICUS/S2_SR_HARMONIZED\")     .filterBounds(region)     .filterDate(\"2024-01-01\", \"2025-01-01\")     .filterMetadata(\"CLOUDY_PIXEL_PERCENTAGE\", \"less_than\", 10)     .select([\"B8\", \"B4\", \"B3\"])     .median()     .multiply(0.0001)     .clip(region) )  image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 0.3}  Map.addLayer(image, image_vis, \"Sentinel 2 FCC\") In\u00a0[\u00a0]: Copied! <pre>scaler = MeanCentering(image, region)\ncentered_image = scaler.transform()\n\n# Adjust visualization range around 0 to reflect centered values\ncentered_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": -0.09, \"max\": 0.09}\nMap.addLayer(centered_image, centered_image_vis, \"MeanCentering\")\n</pre> scaler = MeanCentering(image, region) centered_image = scaler.transform()  # Adjust visualization range around 0 to reflect centered values centered_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": -0.09, \"max\": 0.09} Map.addLayer(centered_image, centered_image_vis, \"MeanCentering\") In\u00a0[\u00a0]: Copied! <pre>scaler = MinMaxScaler(image, region)\nscaled_image = scaler.transform()\n\nscaled_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 1}\nMap.addLayer(scaled_image, scaled_image_vis, \"MinMaxScaler\")\n</pre> scaler = MinMaxScaler(image, region) scaled_image = scaler.transform()  scaled_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 1} Map.addLayer(scaled_image, scaled_image_vis, \"MinMaxScaler\") In\u00a0[\u00a0]: Copied! <pre>scaler = StandardScaler(image, region)\nstandardized_image = scaler.transform()\n\n# You may want to visualize within a reasonable range\nstandardized_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": -2, \"max\": 2}\nMap.addLayer(standardized_image, standardized_image_vis, \"StandardScaler\")\n</pre> scaler = StandardScaler(image, region) standardized_image = scaler.transform()  # You may want to visualize within a reasonable range standardized_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": -2, \"max\": 2} Map.addLayer(standardized_image, standardized_image_vis, \"StandardScaler\") In\u00a0[\u00a0]: Copied! <pre>scaler = RobustScaler(image, region, lower=1, upper=99)\nscaled_image = scaler.transform()\n\nscaled_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 1}\nMap.addLayer(scaled_image, scaled_image_vis, \"RobustScaler\")\n</pre> scaler = RobustScaler(image, region, lower=1, upper=99) scaled_image = scaler.transform()  scaled_image_vis = {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 1} Map.addLayer(scaled_image, scaled_image_vis, \"RobustScaler\") <p>\ud83d\udca1 Tips for Efficient Processing</p> <ul> <li><p>Increase the <code>scale</code> parameter to reduce computation time. Calculating statistics (e.g., mean, percentiles) over high-resolution images (like Sentinel-2 at 10\u202fm) can be time-consuming or cause timeouts. Try <code>scale=100</code> or higher when possible.</p> </li> <li><p>Use simpler geometries. Avoid complex shapes like administrative boundaries or large regions. Instead, use simplified or bounding box geometries.</p> </li> <li><p>You can simplify any geometry by converting it to a bounding rectangle using:</p> <pre>simple_region = complex_region.bounds()\n</pre> <p>This can drastically speed up reduceRegion operations while still capturing spatial context.</p> </li> </ul>"},{"location":"examples/pca/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"examples/pca/#initialize-a-map-object","title":"Initialize a Map object\u00b6","text":"<p>Authenticate and initialize Earth Engine. If it doesn't work, specify a project name</p>"},{"location":"examples/pca/#read-the-tanager-data","title":"Read the Tanager Data\u00b6","text":""},{"location":"examples/pca/#principal-component-analysis","title":"Principal Component Analysis\u00b6","text":""},{"location":"examples/pca/#load-sentinel-2-data-and-create-a-median-composite","title":"Load Sentinel-2 Data and Create a Median Composite\u00b6","text":""},{"location":"examples/pca/#meancentering","title":"MeanCentering\u00b6","text":"<p>Subtracts the mean from each band to center values around zero:</p> <p>$$ X_\\text{centered} = X - \\mu $$</p> <p>Where:</p> <ul> <li>$X$: original pixel value</li> <li>$\\mu$: mean of the band computed over the given region</li> </ul>"},{"location":"examples/pca/#minmaxscaler","title":"MinMaxScaler\u00b6","text":"<p>Normalizes each band using the min and max values over the region:</p> <p>$$ X_\\text{scaled} = \\frac{X - \\min}{\\max - \\min}, \\quad X_\\text{scaled} \\in [0, 1] $$</p> <p>Where:</p> <ul> <li>$\\min$, $\\max$: band-wise minimum and maximum values over the region.</li> </ul>"},{"location":"examples/pca/#standardscaler","title":"StandardScaler\u00b6","text":"<p>Standardizes each band using z-score normalization (mean and standard deviation):</p> <p>$$ X_\\text{standardized} = \\frac{X - \\mu}{\\sigma} $$</p> <p>Where:</p> <ul> <li>$X$: original pixel value</li> <li>$\\mu$: mean of the band over the specified region</li> <li>$\\sigma$: standard deviation of the band over the specified region</li> </ul>"},{"location":"examples/pca/#robustscaler","title":"RobustScaler\u00b6","text":"<p>Scales each band using robust percentiles (e.g., 1st and 99th) to reduce the influence of outliers:</p> <p>$$ X_\\text{scaled} = \\frac{X - P_\\text{lower}}{P_\\text{upper} - P_\\text{lower}}, \\quad X_\\text{scaled} \\in [0, 1] $$</p> <p>Where:</p> <ul> <li>$X$: original pixel value</li> <li>$P_{\\\\text{lower}}$: lower percentile value (e.g., 25th percentile)</li> <li>$P_{\\\\text{upper}}$: upper percentile value (e.g., 75th percentile)</li> </ul>"},{"location":"examples/timeseries_extraction/","title":"Timeseries extraction","text":"<p>Uncomment the following line to install geeagri if needed.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geeagri\n</pre> # !pip install geeagri In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\nfrom geeagri.extract import (\n    extract_timeseries_to_point,\n    extract_timeseries_to_polygon,\n)\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nplt.rcParams[\"font.family\"] = \"DeJavu Serif\"\nplt.rcParams[\"font.serif\"] = \"Times New Roman\"\n</pre> import ee import geemap from geeagri.extract import (     extract_timeseries_to_point,     extract_timeseries_to_polygon, )  import matplotlib.pyplot as plt import seaborn as sns  plt.rcParams[\"font.family\"] = \"DeJavu Serif\" plt.rcParams[\"font.serif\"] = \"Times New Roman\" In\u00a0[\u00a0]: Copied! <pre># ee.Authenticate()\n# ee.Initialize(project='your-project-id')\n\nMap = geemap.Map()\nMap\n</pre> # ee.Authenticate() # ee.Initialize(project='your-project-id')  Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>bbox = [-120.398369, 37.006574, -120.208168, 37.101924]\npolygon = ee.Geometry.BBox(*bbox)\npolygon_style = {\"color\": \"red\", \"width\": 1}\nMap.addLayer(polygon, polygon_style, \"Polygon\")\nMap.centerObject(polygon, 12)\n\nlat, lon = 37.0510, -120.3022\npoint = ee.Geometry.Point([lon, lat])\nMap.addLayer(point, {\"color\": \"blue\"}, \"Point\")\n</pre> bbox = [-120.398369, 37.006574, -120.208168, 37.101924] polygon = ee.Geometry.BBox(*bbox) polygon_style = {\"color\": \"red\", \"width\": 1} Map.addLayer(polygon, polygon_style, \"Polygon\") Map.centerObject(polygon, 12)  lat, lon = 37.0510, -120.3022 point = ee.Geometry.Point([lon, lat]) Map.addLayer(point, {\"color\": \"blue\"}, \"Point\") In\u00a0[\u00a0]: Copied! <pre>era5_land = ee.ImageCollection(\"ECMWF/ERA5_LAND/DAILY_AGGR\")\n\nera5_land_point_ts = extract_timeseries_to_point(\n    lat=lat,\n    lon=lon,\n    image_collection=era5_land,\n    start_date=\"2010-01-01\",\n    end_date=\"2015-01-01\",\n    band_names=[\n        \"temperature_2m_min\",\n        \"temperature_2m_max\",\n        \"total_precipitation_sum\",\n        \"surface_solar_radiation_downwards_sum\",\n    ],\n    scale=11132,\n)\n\nera5_land_polygon_ts = extract_timeseries_to_polygon(\n    polygon=polygon,\n    image_collection=era5_land,\n    start_date=\"2010-01-01\",\n    end_date=\"2015-01-01\",\n    band_names=[\n        \"temperature_2m_min\",\n        \"temperature_2m_max\",\n        \"total_precipitation_sum\",\n        \"surface_solar_radiation_downwards_sum\",\n    ],\n    scale=11132,\n    reducer=\"MEAN\",\n)\n</pre> era5_land = ee.ImageCollection(\"ECMWF/ERA5_LAND/DAILY_AGGR\")  era5_land_point_ts = extract_timeseries_to_point(     lat=lat,     lon=lon,     image_collection=era5_land,     start_date=\"2010-01-01\",     end_date=\"2015-01-01\",     band_names=[         \"temperature_2m_min\",         \"temperature_2m_max\",         \"total_precipitation_sum\",         \"surface_solar_radiation_downwards_sum\",     ],     scale=11132, )  era5_land_polygon_ts = extract_timeseries_to_polygon(     polygon=polygon,     image_collection=era5_land,     start_date=\"2010-01-01\",     end_date=\"2015-01-01\",     band_names=[         \"temperature_2m_min\",         \"temperature_2m_max\",         \"total_precipitation_sum\",         \"surface_solar_radiation_downwards_sum\",     ],     scale=11132,     reducer=\"MEAN\", ) In\u00a0[\u00a0]: Copied! <pre># Plot the data\nfig, axes = plt.subplots(nrows=2, ncols=1, figsize=(12, 6))\naxes = axes.flatten()\n\nsns.lineplot(\n    data=era5_land_point_ts,\n    x=\"time\",\n    y=\"temperature_2m_max\",\n    c=\"r\",\n    linewidth=0.5,\n    ax=axes[0],\n    label=\"Tmax\",\n)\nsns.lineplot(\n    data=era5_land_point_ts,\n    x=\"time\",\n    y=\"temperature_2m_min\",\n    c=\"b\",\n    linewidth=0.5,\n    ax=axes[0],\n    label=\"Tmax\",\n)\naxes[0].set_ylabel(\"Values\")\naxes[0].legend()\naxes[0].set_title(\"Daily timeseries of climate data based on point\")\n\nsns.lineplot(\n    data=era5_land_polygon_ts,\n    x=\"time\",\n    y=\"temperature_2m_max\",\n    c=\"r\",\n    linewidth=0.5,\n    ax=axes[1],\n    label=\"Tmax\",\n)\nsns.lineplot(\n    data=era5_land_polygon_ts,\n    x=\"time\",\n    y=\"temperature_2m_min\",\n    c=\"b\",\n    linewidth=0.5,\n    ax=axes[1],\n    label=\"Tmax\",\n)\naxes[1].set_ylabel(\"Values\")\naxes[1].legend()\naxes[1].set_title(\"Daily timeseries of climate data based on polygon\")\n\nplt.tight_layout()\nplt.show()\n</pre> # Plot the data fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(12, 6)) axes = axes.flatten()  sns.lineplot(     data=era5_land_point_ts,     x=\"time\",     y=\"temperature_2m_max\",     c=\"r\",     linewidth=0.5,     ax=axes[0],     label=\"Tmax\", ) sns.lineplot(     data=era5_land_point_ts,     x=\"time\",     y=\"temperature_2m_min\",     c=\"b\",     linewidth=0.5,     ax=axes[0],     label=\"Tmax\", ) axes[0].set_ylabel(\"Values\") axes[0].legend() axes[0].set_title(\"Daily timeseries of climate data based on point\")  sns.lineplot(     data=era5_land_polygon_ts,     x=\"time\",     y=\"temperature_2m_max\",     c=\"r\",     linewidth=0.5,     ax=axes[1],     label=\"Tmax\", ) sns.lineplot(     data=era5_land_polygon_ts,     x=\"time\",     y=\"temperature_2m_min\",     c=\"b\",     linewidth=0.5,     ax=axes[1],     label=\"Tmax\", ) axes[1].set_ylabel(\"Values\") axes[1].legend() axes[1].set_title(\"Daily timeseries of climate data based on polygon\")  plt.tight_layout() plt.show() In\u00a0[\u00a0]: Copied! <pre>modis_ndvi = ee.ImageCollection(\"MODIS/061/MOD13Q1\")\n\nmodis_ndvi_point_ts = extract_timeseries_to_point(\n    lat=lat,\n    lon=lon,\n    image_collection=modis_ndvi,\n    start_date=\"2010-01-01\",\n    end_date=\"2015-01-01\",\n    band_names=[\"NDVI\", \"EVI\"],\n    scale=250,\n)\n\nmodis_ndvi_polygon_ts = extract_timeseries_to_polygon(\n    polygon=polygon,\n    image_collection=modis_ndvi,\n    start_date=\"2010-01-01\",\n    end_date=\"2015-01-01\",\n    band_names=[\"NDVI\", \"EVI\"],\n    scale=250,\n    reducer=\"MEAN\",\n)\n\n# Apply scale factors\nmodis_ndvi_point_ts[[\"NDVI\", \"EVI\"]] = modis_ndvi_point_ts[[\"NDVI\", \"EVI\"]] * 0.0001\nmodis_ndvi_polygon_ts[[\"NDVI\", \"EVI\"]] = modis_ndvi_polygon_ts[[\"NDVI\", \"EVI\"]] * 0.0001\n</pre> modis_ndvi = ee.ImageCollection(\"MODIS/061/MOD13Q1\")  modis_ndvi_point_ts = extract_timeseries_to_point(     lat=lat,     lon=lon,     image_collection=modis_ndvi,     start_date=\"2010-01-01\",     end_date=\"2015-01-01\",     band_names=[\"NDVI\", \"EVI\"],     scale=250, )  modis_ndvi_polygon_ts = extract_timeseries_to_polygon(     polygon=polygon,     image_collection=modis_ndvi,     start_date=\"2010-01-01\",     end_date=\"2015-01-01\",     band_names=[\"NDVI\", \"EVI\"],     scale=250,     reducer=\"MEAN\", )  # Apply scale factors modis_ndvi_point_ts[[\"NDVI\", \"EVI\"]] = modis_ndvi_point_ts[[\"NDVI\", \"EVI\"]] * 0.0001 modis_ndvi_polygon_ts[[\"NDVI\", \"EVI\"]] = modis_ndvi_polygon_ts[[\"NDVI\", \"EVI\"]] * 0.0001 In\u00a0[\u00a0]: Copied! <pre># Plot the data\nfig, axes = plt.subplots(nrows=2, ncols=1, figsize=(12, 6))\naxes = axes.flatten()\n\nsns.lineplot(\n    data=modis_ndvi_point_ts,\n    x=\"time\",\n    y=\"NDVI\",\n    c=\"green\",\n    marker=\"o\",\n    markersize=5,\n    linewidth=1,\n    ax=axes[0],\n    label=\"NDVI\",\n)\nsns.lineplot(\n    data=modis_ndvi_point_ts,\n    x=\"time\",\n    y=\"EVI\",\n    c=\"orange\",\n    marker=\"o\",\n    markersize=5,\n    linewidth=1,\n    ax=axes[0],\n    label=\"EVI\",\n)\naxes[0].set_ylabel(\"Values\")\naxes[0].legend()\naxes[0].set_title(\"Daily timeseries of NDVI and EVI data based on point\")\n\nsns.lineplot(\n    data=modis_ndvi_polygon_ts,\n    x=\"time\",\n    y=\"NDVI\",\n    c=\"green\",\n    marker=\"o\",\n    markersize=5,\n    linewidth=1,\n    ax=axes[1],\n    label=\"NDVI\",\n)\nsns.lineplot(\n    data=modis_ndvi_polygon_ts,\n    x=\"time\",\n    y=\"EVI\",\n    c=\"orange\",\n    marker=\"o\",\n    markersize=5,\n    linewidth=1,\n    ax=axes[1],\n    label=\"EVI\",\n)\naxes[1].set_ylabel(\"Values\")\naxes[1].legend()\naxes[1].set_title(\"Daily timeseries of NDVI and EVI data based on polygon\")\n\nplt.tight_layout()\nplt.show()\n</pre> # Plot the data fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(12, 6)) axes = axes.flatten()  sns.lineplot(     data=modis_ndvi_point_ts,     x=\"time\",     y=\"NDVI\",     c=\"green\",     marker=\"o\",     markersize=5,     linewidth=1,     ax=axes[0],     label=\"NDVI\", ) sns.lineplot(     data=modis_ndvi_point_ts,     x=\"time\",     y=\"EVI\",     c=\"orange\",     marker=\"o\",     markersize=5,     linewidth=1,     ax=axes[0],     label=\"EVI\", ) axes[0].set_ylabel(\"Values\") axes[0].legend() axes[0].set_title(\"Daily timeseries of NDVI and EVI data based on point\")  sns.lineplot(     data=modis_ndvi_polygon_ts,     x=\"time\",     y=\"NDVI\",     c=\"green\",     marker=\"o\",     markersize=5,     linewidth=1,     ax=axes[1],     label=\"NDVI\", ) sns.lineplot(     data=modis_ndvi_polygon_ts,     x=\"time\",     y=\"EVI\",     c=\"orange\",     marker=\"o\",     markersize=5,     linewidth=1,     ax=axes[1],     label=\"EVI\", ) axes[1].set_ylabel(\"Values\") axes[1].legend() axes[1].set_title(\"Daily timeseries of NDVI and EVI data based on polygon\")  plt.tight_layout() plt.show()"},{"location":"examples/timeseries_extraction/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"examples/timeseries_extraction/#initialize-a-map-object","title":"Initialize a Map object\u00b6","text":"<p>Authenticate and initialize Earth Engine. If it doesn't work, specify a project name</p>"},{"location":"examples/timeseries_extraction/#import-region-of-interest","title":"Import region of interest\u00b6","text":""},{"location":"examples/timeseries_extraction/#export-timeseries-from-climate-data-era5-land-daily","title":"Export timeseries from climate data (ERA5-Land Daily)\u00b6","text":""},{"location":"examples/timeseries_extraction/#export-timeseries-from-ndvi-data-mod13q1061-terra-vegetation-indices-16-day","title":"Export timeseries from NDVI data (MOD13Q1.061 Terra Vegetation Indices 16-Day)\u00b6","text":""}]}